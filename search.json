[{"path":"https://bafuentes.github.io/rassta/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"GNU Affero General Public License","title":"GNU Affero General Public License","text":"Version 3, 19 November 2007 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/> Everyone permitted copy distribute verbatim copies license document, changing allowed.","code":""},{"path":"https://bafuentes.github.io/rassta/LICENSE.html","id":"preamble","dir":"","previous_headings":"","what":"Preamble","title":"GNU Affero General Public License","text":"GNU Affero General Public License free, copyleft license software kinds works, specifically designed ensure cooperation community case network server software. licenses software practical works designed take away freedom share change works. contrast, General Public Licenses intended guarantee freedom share change versions program–make sure remains free software users. speak free software, referring freedom, price. General Public Licenses designed make sure freedom distribute copies free software (charge wish), receive source code can get want , can change software use pieces new free programs, know can things. Developers use General Public Licenses protect rights two steps: (1) assert copyright software, (2) offer License gives legal permission copy, distribute /modify software. secondary benefit defending users’ freedom improvements made alternate versions program, receive widespread use, become available developers incorporate. Many developers free software heartened encouraged resulting cooperation. However, case software used network servers, result may fail come . GNU General Public License permits making modified version letting public access server without ever releasing source code public. GNU Affero General Public License designed specifically ensure , cases, modified source code becomes available community. requires operator network server provide source code modified version running users server. Therefore, public use modified version, publicly accessible server, gives public access source code modified version. older license, called Affero General Public License published Affero, designed accomplish similar goals. different license, version Affero GPL, Affero released new version Affero GPL permits relicensing license. precise terms conditions copying, distribution modification follow.","code":""},{"path":[]},{"path":"https://bafuentes.github.io/rassta/LICENSE.html","id":"0-definitions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"0. Definitions.","title":"GNU Affero General Public License","text":"“License” refers version 3 GNU Affero General Public License. “Copyright” also means copyright-like laws apply kinds works, semiconductor masks. “Program” refers copyrightable work licensed License. licensee addressed “”. “Licensees” “recipients” may individuals organizations. “modify” work means copy adapt part work fashion requiring copyright permission, making exact copy. resulting work called “modified version” earlier work work “based ” earlier work. “covered work” means either unmodified Program work based Program. “propagate” work means anything , without permission, make directly secondarily liable infringement applicable copyright law, except executing computer modifying private copy. Propagation includes copying, distribution (without modification), making available public, countries activities well. “convey” work means kind propagation enables parties make receive copies. Mere interaction user computer network, transfer copy, conveying. interactive user interface displays “Appropriate Legal Notices” extent includes convenient prominently visible feature (1) displays appropriate copyright notice, (2) tells user warranty work (except extent warranties provided), licensees may convey work License, view copy License. interface presents list user commands options, menu, prominent item list meets criterion.","code":""},{"path":"https://bafuentes.github.io/rassta/LICENSE.html","id":"1-source-code","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"1. Source Code.","title":"GNU Affero General Public License","text":"“source code” work means preferred form work making modifications . “Object code” means non-source form work. “Standard Interface” means interface either official standard defined recognized standards body, , case interfaces specified particular programming language, one widely used among developers working language. “System Libraries” executable work include anything, work whole, () included normal form packaging Major Component, part Major Component, (b) serves enable use work Major Component, implement Standard Interface implementation available public source code form. “Major Component”, context, means major essential component (kernel, window system, ) specific operating system () executable work runs, compiler used produce work, object code interpreter used run . “Corresponding Source” work object code form means source code needed generate, install, (executable work) run object code modify work, including scripts control activities. However, include work’s System Libraries, general-purpose tools generally available free programs used unmodified performing activities part work. example, Corresponding Source includes interface definition files associated source files work, source code shared libraries dynamically linked subprograms work specifically designed require, intimate data communication control flow subprograms parts work. Corresponding Source need include anything users can regenerate automatically parts Corresponding Source. Corresponding Source work source code form work.","code":""},{"path":"https://bafuentes.github.io/rassta/LICENSE.html","id":"2-basic-permissions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"2. Basic Permissions.","title":"GNU Affero General Public License","text":"rights granted License granted term copyright Program, irrevocable provided stated conditions met. License explicitly affirms unlimited permission run unmodified Program. output running covered work covered License output, given content, constitutes covered work. License acknowledges rights fair use equivalent, provided copyright law. may make, run propagate covered works convey, without conditions long license otherwise remains force. may convey covered works others sole purpose make modifications exclusively , provide facilities running works, provided comply terms License conveying material control copyright. thus making running covered works must exclusively behalf, direction control, terms prohibit making copies copyrighted material outside relationship . Conveying circumstances permitted solely conditions stated . Sublicensing allowed; section 10 makes unnecessary.","code":""},{"path":"https://bafuentes.github.io/rassta/LICENSE.html","id":"3-protecting-users-legal-rights-from-anti-circumvention-law","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"3. Protecting Users’ Legal Rights From Anti-Circumvention Law.","title":"GNU Affero General Public License","text":"covered work shall deemed part effective technological measure applicable law fulfilling obligations article 11 WIPO copyright treaty adopted 20 December 1996, similar laws prohibiting restricting circumvention measures. convey covered work, waive legal power forbid circumvention technological measures extent circumvention effected exercising rights License respect covered work, disclaim intention limit operation modification work means enforcing, work’s users, third parties’ legal rights forbid circumvention technological measures.","code":""},{"path":"https://bafuentes.github.io/rassta/LICENSE.html","id":"4-conveying-verbatim-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"4. Conveying Verbatim Copies.","title":"GNU Affero General Public License","text":"may convey verbatim copies Program’s source code receive , medium, provided conspicuously appropriately publish copy appropriate copyright notice; keep intact notices stating License non-permissive terms added accord section 7 apply code; keep intact notices absence warranty; give recipients copy License along Program. may charge price price copy convey, may offer support warranty protection fee.","code":""},{"path":"https://bafuentes.github.io/rassta/LICENSE.html","id":"5-conveying-modified-source-versions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"5. Conveying Modified Source Versions.","title":"GNU Affero General Public License","text":"may convey work based Program, modifications produce Program, form source code terms section 4, provided also meet conditions: work must carry prominent notices stating modified , giving relevant date. work must carry prominent notices stating released License conditions added section 7. requirement modifies requirement section 4 “keep intact notices”. must license entire work, whole, License anyone comes possession copy. License therefore apply, along applicable section 7 additional terms, whole work, parts, regardless packaged. License gives permission license work way, invalidate permission separately received . work interactive user interfaces, must display Appropriate Legal Notices; however, Program interactive interfaces display Appropriate Legal Notices, work need make . compilation covered work separate independent works, nature extensions covered work, combined form larger program, volume storage distribution medium, called “aggregate” compilation resulting copyright used limit access legal rights compilation’s users beyond individual works permit. Inclusion covered work aggregate cause License apply parts aggregate.","code":""},{"path":"https://bafuentes.github.io/rassta/LICENSE.html","id":"6-conveying-non-source-forms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"6. Conveying Non-Source Forms.","title":"GNU Affero General Public License","text":"may convey covered work object code form terms sections 4 5, provided also convey machine-readable Corresponding Source terms License, one ways: Convey object code , embodied , physical product (including physical distribution medium), accompanied Corresponding Source fixed durable physical medium customarily used software interchange. Convey object code , embodied , physical product (including physical distribution medium), accompanied written offer, valid least three years valid long offer spare parts customer support product model, give anyone possesses object code either (1) copy Corresponding Source software product covered License, durable physical medium customarily used software interchange, price reasonable cost physically performing conveying source, (2) access copy Corresponding Source network server charge. Convey individual copies object code copy written offer provide Corresponding Source. alternative allowed occasionally noncommercially, received object code offer, accord subsection 6b. Convey object code offering access designated place (gratis charge), offer equivalent access Corresponding Source way place charge. need require recipients copy Corresponding Source along object code. place copy object code network server, Corresponding Source may different server (operated third party) supports equivalent copying facilities, provided maintain clear directions next object code saying find Corresponding Source. Regardless server hosts Corresponding Source, remain obligated ensure available long needed satisfy requirements. Convey object code using peer--peer transmission, provided inform peers object code Corresponding Source work offered general public charge subsection 6d. separable portion object code, whose source code excluded Corresponding Source System Library, need included conveying object code work. “User Product” either (1) “consumer product”, means tangible personal property normally used personal, family, household purposes, (2) anything designed sold incorporation dwelling. determining whether product consumer product, doubtful cases shall resolved favor coverage. particular product received particular user, “normally used” refers typical common use class product, regardless status particular user way particular user actually uses, expects expected use, product. product consumer product regardless whether product substantial commercial, industrial non-consumer uses, unless uses represent significant mode use product. “Installation Information” User Product means methods, procedures, authorization keys, information required install execute modified versions covered work User Product modified version Corresponding Source. information must suffice ensure continued functioning modified object code case prevented interfered solely modification made. convey object code work section , , specifically use , User Product, conveying occurs part transaction right possession use User Product transferred recipient perpetuity fixed term (regardless transaction characterized), Corresponding Source conveyed section must accompanied Installation Information. requirement apply neither third party retains ability install modified object code User Product (example, work installed ROM). requirement provide Installation Information include requirement continue provide support service, warranty, updates work modified installed recipient, User Product modified installed. Access network may denied modification materially adversely affects operation network violates rules protocols communication across network. Corresponding Source conveyed, Installation Information provided, accord section must format publicly documented (implementation available public source code form), must require special password key unpacking, reading copying.","code":""},{"path":"https://bafuentes.github.io/rassta/LICENSE.html","id":"7-additional-terms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"7. Additional Terms.","title":"GNU Affero General Public License","text":"“Additional permissions” terms supplement terms License making exceptions one conditions. Additional permissions applicable entire Program shall treated though included License, extent valid applicable law. additional permissions apply part Program, part may used separately permissions, entire Program remains governed License without regard additional permissions. convey copy covered work, may option remove additional permissions copy, part . (Additional permissions may written require removal certain cases modify work.) may place additional permissions material, added covered work, can give appropriate copyright permission. Notwithstanding provision License, material add covered work, may (authorized copyright holders material) supplement terms License terms: Disclaiming warranty limiting liability differently terms sections 15 16 License; Requiring preservation specified reasonable legal notices author attributions material Appropriate Legal Notices displayed works containing ; Prohibiting misrepresentation origin material, requiring modified versions material marked reasonable ways different original version; Limiting use publicity purposes names licensors authors material; Declining grant rights trademark law use trade names, trademarks, service marks; Requiring indemnification licensors authors material anyone conveys material (modified versions ) contractual assumptions liability recipient, liability contractual assumptions directly impose licensors authors. non-permissive additional terms considered “restrictions” within meaning section 10. Program received , part , contains notice stating governed License along term restriction, may remove term. license document contains restriction permits relicensing conveying License, may add covered work material governed terms license document, provided restriction survive relicensing conveying. add terms covered work accord section, must place, relevant source files, statement additional terms apply files, notice indicating find applicable terms. Additional terms, permissive non-permissive, may stated form separately written license, stated exceptions; requirements apply either way.","code":""},{"path":"https://bafuentes.github.io/rassta/LICENSE.html","id":"8-termination","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"8. Termination.","title":"GNU Affero General Public License","text":"may propagate modify covered work except expressly provided License. attempt otherwise propagate modify void, automatically terminate rights License (including patent licenses granted third paragraph section 11). However, cease violation License, license particular copyright holder reinstated () provisionally, unless copyright holder explicitly finally terminates license, (b) permanently, copyright holder fails notify violation reasonable means prior 60 days cessation. Moreover, license particular copyright holder reinstated permanently copyright holder notifies violation reasonable means, first time received notice violation License (work) copyright holder, cure violation prior 30 days receipt notice. Termination rights section terminate licenses parties received copies rights License. rights terminated permanently reinstated, qualify receive new licenses material section 10.","code":""},{"path":"https://bafuentes.github.io/rassta/LICENSE.html","id":"9-acceptance-not-required-for-having-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"9. Acceptance Not Required for Having Copies.","title":"GNU Affero General Public License","text":"required accept License order receive run copy Program. Ancillary propagation covered work occurring solely consequence using peer--peer transmission receive copy likewise require acceptance. However, nothing License grants permission propagate modify covered work. actions infringe copyright accept License. Therefore, modifying propagating covered work, indicate acceptance License .","code":""},{"path":"https://bafuentes.github.io/rassta/LICENSE.html","id":"10-automatic-licensing-of-downstream-recipients","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"10. Automatic Licensing of Downstream Recipients.","title":"GNU Affero General Public License","text":"time convey covered work, recipient automatically receives license original licensors, run, modify propagate work, subject License. responsible enforcing compliance third parties License. “entity transaction” transaction transferring control organization, substantially assets one, subdividing organization, merging organizations. propagation covered work results entity transaction, party transaction receives copy work also receives whatever licenses work party’s predecessor interest give previous paragraph, plus right possession Corresponding Source work predecessor interest, predecessor can get reasonable efforts. may impose restrictions exercise rights granted affirmed License. example, may impose license fee, royalty, charge exercise rights granted License, may initiate litigation (including cross-claim counterclaim lawsuit) alleging patent claim infringed making, using, selling, offering sale, importing Program portion .","code":""},{"path":"https://bafuentes.github.io/rassta/LICENSE.html","id":"11-patents","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"11. Patents.","title":"GNU Affero General Public License","text":"“contributor” copyright holder authorizes use License Program work Program based. work thus licensed called contributor’s “contributor version”. contributor’s “essential patent claims” patent claims owned controlled contributor, whether already acquired hereafter acquired, infringed manner, permitted License, making, using, selling contributor version, include claims infringed consequence modification contributor version. purposes definition, “control” includes right grant patent sublicenses manner consistent requirements License. contributor grants non-exclusive, worldwide, royalty-free patent license contributor’s essential patent claims, make, use, sell, offer sale, import otherwise run, modify propagate contents contributor version. following three paragraphs, “patent license” express agreement commitment, however denominated, enforce patent (express permission practice patent covenant sue patent infringement). “grant” patent license party means make agreement commitment enforce patent party. convey covered work, knowingly relying patent license, Corresponding Source work available anyone copy, free charge terms License, publicly available network server readily accessible means, must either (1) cause Corresponding Source available, (2) arrange deprive benefit patent license particular work, (3) arrange, manner consistent requirements License, extend patent license downstream recipients. “Knowingly relying” means actual knowledge , patent license, conveying covered work country, recipient’s use covered work country, infringe one identifiable patents country reason believe valid. , pursuant connection single transaction arrangement, convey, propagate procuring conveyance , covered work, grant patent license parties receiving covered work authorizing use, propagate, modify convey specific copy covered work, patent license grant automatically extended recipients covered work works based . patent license “discriminatory” include within scope coverage, prohibits exercise , conditioned non-exercise one rights specifically granted License. may convey covered work party arrangement third party business distributing software, make payment third party based extent activity conveying work, third party grants, parties receive covered work , discriminatory patent license () connection copies covered work conveyed (copies made copies), (b) primarily connection specific products compilations contain covered work, unless entered arrangement, patent license granted, prior 28 March 2007. Nothing License shall construed excluding limiting implied license defenses infringement may otherwise available applicable patent law.","code":""},{"path":"https://bafuentes.github.io/rassta/LICENSE.html","id":"12-no-surrender-of-others-freedom","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"12. No Surrender of Others’ Freedom.","title":"GNU Affero General Public License","text":"conditions imposed (whether court order, agreement otherwise) contradict conditions License, excuse conditions License. convey covered work satisfy simultaneously obligations License pertinent obligations, consequence may convey . example, agree terms obligate collect royalty conveying convey Program, way satisfy terms License refrain entirely conveying Program.","code":""},{"path":"https://bafuentes.github.io/rassta/LICENSE.html","id":"13-remote-network-interaction-use-with-the-gnu-general-public-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"13. Remote Network Interaction; Use with the GNU General Public License.","title":"GNU Affero General Public License","text":"Notwithstanding provision License, modify Program, modified version must prominently offer users interacting remotely computer network (version supports interaction) opportunity receive Corresponding Source version providing access Corresponding Source network server charge, standard customary means facilitating copying software. Corresponding Source shall include Corresponding Source work covered version 3 GNU General Public License incorporated pursuant following paragraph. Notwithstanding provision License, permission link combine covered work work licensed version 3 GNU General Public License single combined work, convey resulting work. terms License continue apply part covered work, work combined remain governed version 3 GNU General Public License.","code":""},{"path":"https://bafuentes.github.io/rassta/LICENSE.html","id":"14-revised-versions-of-this-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"14. Revised Versions of this License.","title":"GNU Affero General Public License","text":"Free Software Foundation may publish revised /new versions GNU Affero General Public License time time. new versions similar spirit present version, may differ detail address new problems concerns. version given distinguishing version number. Program specifies certain numbered version GNU Affero General Public License “later version” applies , option following terms conditions either numbered version later version published Free Software Foundation. Program specify version number GNU Affero General Public License, may choose version ever published Free Software Foundation. Program specifies proxy can decide future versions GNU Affero General Public License can used, proxy’s public statement acceptance version permanently authorizes choose version Program. Later license versions may give additional different permissions. However, additional obligations imposed author copyright holder result choosing follow later version.","code":""},{"path":"https://bafuentes.github.io/rassta/LICENSE.html","id":"15-disclaimer-of-warranty","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"15. Disclaimer of Warranty.","title":"GNU Affero General Public License","text":"WARRANTY PROGRAM, EXTENT PERMITTED APPLICABLE LAW. EXCEPT OTHERWISE STATED WRITING COPYRIGHT HOLDERS /PARTIES PROVIDE PROGRAM “” WITHOUT WARRANTY KIND, EITHER EXPRESSED IMPLIED, INCLUDING, LIMITED , IMPLIED WARRANTIES MERCHANTABILITY FITNESS PARTICULAR PURPOSE. ENTIRE RISK QUALITY PERFORMANCE PROGRAM . PROGRAM PROVE DEFECTIVE, ASSUME COST NECESSARY SERVICING, REPAIR CORRECTION.","code":""},{"path":"https://bafuentes.github.io/rassta/LICENSE.html","id":"16-limitation-of-liability","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"16. Limitation of Liability.","title":"GNU Affero General Public License","text":"EVENT UNLESS REQUIRED APPLICABLE LAW AGREED WRITING COPYRIGHT HOLDER, PARTY MODIFIES /CONVEYS PROGRAM PERMITTED , LIABLE DAMAGES, INCLUDING GENERAL, SPECIAL, INCIDENTAL CONSEQUENTIAL DAMAGES ARISING USE INABILITY USE PROGRAM (INCLUDING LIMITED LOSS DATA DATA RENDERED INACCURATE LOSSES SUSTAINED THIRD PARTIES FAILURE PROGRAM OPERATE PROGRAMS), EVEN HOLDER PARTY ADVISED POSSIBILITY DAMAGES.","code":""},{"path":"https://bafuentes.github.io/rassta/LICENSE.html","id":"17-interpretation-of-sections-15-and-16","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"17. Interpretation of Sections 15 and 16.","title":"GNU Affero General Public License","text":"disclaimer warranty limitation liability provided given local legal effect according terms, reviewing courts shall apply local law closely approximates absolute waiver civil liability connection Program, unless warranty assumption liability accompanies copy Program return fee. END TERMS CONDITIONS","code":""},{"path":"https://bafuentes.github.io/rassta/LICENSE.html","id":"how-to-apply-these-terms-to-your-new-programs","dir":"","previous_headings":"","what":"How to Apply These Terms to Your New Programs","title":"GNU Affero General Public License","text":"develop new program, want greatest possible use public, best way achieve make free software everyone can redistribute change terms. , attach following notices program. safest attach start source file effectively state exclusion warranty; file least “copyright” line pointer full notice found. Also add information contact electronic paper mail. software can interact users remotely computer network, also make sure provides way users get source. example, program web application, interface display “Source” link leads users archive code. many ways offer source, different solutions better different programs; see section 13 specific requirements. also get employer (work programmer) school, , sign “copyright disclaimer” program, necessary. information , apply follow GNU AGPL, see https://www.gnu.org/licenses/.","code":"<one line to give the program's name and a brief idea of what it does.>     Copyright (C) <year>  <name of author>      This program is free software: you can redistribute it and/or modify     it under the terms of the GNU Affero General Public License as     published by the Free Software Foundation, either version 3 of the     License, or (at your option) any later version.      This program is distributed in the hope that it will be useful,     but WITHOUT ANY WARRANTY; without even the implied warranty of     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     GNU Affero General Public License for more details.      You should have received a copy of the GNU Affero General Public License     along with this program.  If not, see <https://www.gnu.org/licenses/>."},{"path":"https://bafuentes.github.io/rassta/articles/classunits.html","id":"dimension-reduction-and-estimation-of-k","dir":"Articles","previous_headings":"","what":"Dimension reduction and estimation of k","title":"Classification Units","text":"process create classification units starts reduction feature space represented n variables. low-dimension representation feature space created using self-organizing map (SOM) technique Kohonen (1982, 1990). Subsequently, cluster analysis performed reduced feature space using partitioning around medoids (PAM) algorithm (Kaufman Rousseeuw, 1990). ‘optimal’ number clusters k estimated gap statistic Tibshirani et al. (2001). packages kohonen (Wehrens Kruisselbrink, 2018) cluster (Maechler et al., 2021) imported rassta perform SOM technique PAM clustering gap statistic, respectively. following code examples demonstrate reduce feature space estimate optimum k using four terrain variables function som_gap.","code":"# Load rassta and terra packages library(rassta) library(terra) # Multi-layer SpatRaster with 4 terrain variables var <- c(\"height.tif\", \"midslope.tif\", \"slope.tif\", \"wetness.tif\") vardir <- paste(d, var, sep = \"/\") terr.var <- rast(vardir) # Plot terrain variables par(mfrow = c(2,2)) nc <- c(\"Zissou\", \"Batlow\", \"Lajolla\", \"Spectral\") for(i in 1:4){   plot(terr.var[[i]], main = names(terr.var)[i],        col = hcl.colors(100, nc[i]), mar = c(2, 2, 2, 3.5)       ) } # Set seed set.seed(963) # Scale variables to mean = 0 and standard deviation = 1 terr.varscale <- scale(terr.var) # With terra::aggregate(), reduce spatial resolution to reduce computing time terr.varscale <- aggregate(terr.varscale, fact = 3) # Dimensionality reduction and estimation of optimum k (max k to evaluate: 9) terr.som <- som_gap(terr.varscale, xdim = 9, ydim = 9, K.max = 9) # Plot results plot(terr.som$SOM, main = \"SOM Codes\") # Self-Organizing Map's codes par(mar = c(4.5, 4.5, 2, 1)) plot(terr.som$SOMgap, main = \"Gap Statistic\") # Gap statistic abline(v = terr.som$Kopt) # Optimum k"},{"path":"https://bafuentes.github.io/rassta/articles/classunits.html","id":"rasterization-of-the-som-and-pam-outputs","dir":"Articles","previous_headings":"","what":"Rasterization of the SOM and PAM outputs","title":"Classification Units","text":"feature space reduced optimum k estimated som_gap, rasterized versions SOM PAM outputs can created function som_pam. rasterized PAM represents final set classification units landscape factor. Note clustering algorithm outside rassta can used create classification units output SOM som_gap. code demonstrates creation classification units som_pam.","code":"# Create reference SpatRaster rastref <- aggregate(terr.var[[1]], fact = 3) # Rasterization of terrain SOM grid and terrain PAM clustering terr.sompam <- som_pam(ref.rast = rastref, kohsom = terr.som$SOM,                        k = terr.som$Kopt                       ) # Plot results plot(terr.sompam$sompam.rast[[1]], main = \"Terrain Self-Organizing Map\",      mar = c(1.5, 1.3, 1.5, 3.3), col = hcl.colors(100, \"spectral\", rev = TRUE)     ) plot(terr.sompam$sompam.rast[[2]], main = \"Terrain Classification Units\",      type = \"classes\", col = hcl.colors(terr.som$Kopt, \"spectral\", rev = TRUE),      mar = c(1.5, 2, 1.5, 2.5)     )"},{"path":"https://bafuentes.github.io/rassta/articles/classunits.html","id":"reclassification","dir":"Articles","previous_headings":"Rasterization of the SOM and PAM outputs","what":"Reclassification","title":"Classification Units","text":"Note using terra, numeric IDs classification units can reassigned according interpretation unit. assignment new IDs classes commonly referred ‘reclassification’ geospatial analysis literature. next code example, numeric ID terrain classification units reassigned based variable height. Terrain classes higher relative positions (e.g., summits) values closer one. Conversely, terrain classes lower relative positions (e.g., stream channels) values closer 6.  Clean files temporary directory","code":"# Extract rasterized PAM solution terr.cu <- terr.sompam$sompam.rast[[2]] # With terra::zonal(), unit-wise mean value of terrain height terrh <- aggregate(terr.var$height, fact = 3) # Match spatial resolution terr.stat <- zonal(terrh, terr.cu, fun = mean) # Order numeric IDs based on terrain height (descending) terr.stat <- terr.stat[order(terr.stat$height, decreasing = TRUE), ] # Column with original numeric IDs terr.stat$CU <- seq(1, terr.som$Kopt) # With terra::classify(), reclassify numeric IDs terr.cu <- classify(terr.cu, terr.stat[, c(1,3)]) # Plot original and reclassified terrain classification units plot(terr.sompam$sompam.rast[[2]], main = \"Terrain Classification Units\",      type = \"classes\", col = hcl.colors(terr.som$Kopt, \"spectral\", rev = TRUE),      mar = c(1.5, 2, 1.5, 2.5)     ) plot(terr.cu, type = \"classes\", col = hcl.colors(terr.som$Kopt, \"spectral\"),      main = \"Reclassified Terrain Classification Units\",      mar = c(1.5, 2, 1.5, 2.5)     ) unlink(c(paste(o, \"/wasoil.zip\", sep = \"\"), d), recursive = TRUE)"},{"path":"https://bafuentes.github.io/rassta/articles/classunits.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Classification Units","text":"B.. Fuentes, M.J. Dorantes, J.R. Tipton. rassta: Raster-based Spatial Stratification Algorithms. EarthArXiv, 2021. https://doi.org/10.31223/X50S57 L. Kaufman P. Rousseeuw. Finding groups data: introduction cluster analysis. John Wiley & Sons, 1990. https://doi.org/10.1002/9780470316801 T. Kohonen. Self-organized formation topologically correct feature maps. Biological Cybernetics, 43 (1):59–69, 1982. https://doi.org/10.1007/bf00337288 T. Kohonen. self-organizing map. Proceedings IEEE, 1990. https://doi.org/10.1016/s0925-2312(98)00030-7 M. Maechler, P. Rousseeuw, . Struyf, M. Hubert, K. Hornik. cluster: Cluster Analysis Basics Extensions. R package version 2.1.2, 2021. https://CRAN.R-project.org/package=cluster R. Tibshirani, G. Walther, T. Hastie. Estimating number clusters data set via gap statistic. Journal Royal Statistical Society: Series B (Statistical Methodology), 63(2):411–423, 2001. https://doi.org/10.1111/1467-9868.00293 R. Wehrens J. Kruisselbrink. Flexible self-organizing maps kohonen 3.0. Journal Statistical Software, 87(1):1–18, 2018. https://doi.org/10.18637/jss.v087.i07","code":""},{"path":"https://bafuentes.github.io/rassta/articles/modeling.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Predictive Modeling Engine","text":"B.. Fuentes, M.J. Dorantes, J.R. Tipton. rassta: Raster-based Spatial Stratification Algorithms. EarthArXiv, 2021. https://doi.org/10.31223/X50S57","code":""},{"path":"https://bafuentes.github.io/rassta/articles/sampling.html","id":"selection-of-representative-observations","dir":"Articles","previous_headings":"","what":"Selection of representative observations","title":"Stratified Non-Probability Sampling","text":"selection observations existing sample rassta results one observation per stratification unit set. observation termed representative response observation. representative response observation assumed best reflect control landscape configuration represented stratification unit exerts response phenomena. Currently, rassta allows select representative response observation stratification unit set based following methods: mls: selects observation location maximum landscape similarity value. mrv: selects observation whose response value median values. random: selects observation random. first two methods represent stratified non-probability sampling, third method represents stratified random sampling. Moreover, first method biased towards maximizing representativeness landscape configurations uses landscape similarity layers. codes demonstrate selection representative response observations observation(). observations selected sample n = 195 based mls method. Creation multi-layer SpatRaster landscape similarity stratification units. Selection representative response observation stratification unit. response variable example soil organic carbon (SOC). spatial statistical distribution sample representative response observations can plotted demonstrated code .","code":"# Load rassta and terra packages library(rassta) library(terra) # Single-layer SpatRaster of stratification units su <- rast(paste(d, \"/su.tif\", sep = \"\")) # Multi-layer SpatRaster with spatial signatures of classification units clim.sig <- rast(list.files(d, pattern = \"climate_\", full.names = TRUE)) # For climatic units mat.sig <- rast(list.files(d, pattern = \"material_\", full.names = TRUE)) # For material units terr.sig <- rast(list.files(d, pattern = \"terrain_\", full.names = TRUE)) # For terrain units # Landscape similarity to stratification units su.ls <- similarity(su.rast = su, sig.rast = c(clim.sig, mat.sig, terr.sig),                     su.code = list(climate = c(1, 1),                                    material = c(2, 2),                                    terrain = c(3, 3)                                    )                   ) # SpatVector with SOC observations for stratification units socobs <- vect(paste(d, \"/soc.shp\", sep = \"\")) # Representative SOC observation for each stratification unit su.obs <- observation(su.rast = su, obs = socobs, col.id = 1, col.resp = 2,                       method = \"mls\", ls.rast = su.ls$landsim                       ) # Information about sample and representative SOC observations socobs #>  class       : SpatVector  #>  geometry    : points  #>  dimensions  : 195, 2  (geometries, attributes) #>  extent      : 284252, 292532, 153471, 161811  (xmin, xmax, ymin, ymax) #>  source      : soc.shp #>  coord. ref. : NAD83 / Washington South (EPSG:32149)  #>  names       :    ID   soc #>  type        : <int> <num> #>  values      :     1 6.603 #>                    2 5.701 #>                    3 5.594 su.obs$su_repobs.sp #>  class       : SpatVector  #>  geometry    : points  #>  dimensions  : 56, 4  (geometries, attributes) #>  extent      : 284252, 292532, 153651, 161811  (xmin, xmax, ymin, ymax) #>  coord. ref. : NAD83 / Washington South (EPSG:32149)  #>  names       :    ID   soc    SU land_sim #>  type        : <int> <num> <int>    <num> #>  values      :     1 6.603   111    80.67 #>                    6 5.443   112       85 #>                   10 4.609   114    77.33 # Set graphics arrangement par(mfrow = c(1,2)) # Plot stratification units and response observations plot(su, type = \"classes\", col = hcl.colors(56, \"spectral\"), legend = FALSE,      mar = c(3, 2, 3, 1.5), main = paste(\"Soil Organic Carbon Observations\"),      fun = function() c(points(socobs, pch = 21, bg = rgb(0,1,0,1)),                         points(su.obs$su_repobs.sp, pch = 21, bg = rgb(0,0,1,1))                       )     ) # Set new graphics arrangement par(mar = c(2, 1.5, 1.5, 1.5)) # Plot histogram of soil organic carbon values from all observations hist(socobs$soc, 4, col = rgb(0,1,0,0.8), main = \"Soil Organic Carbon (%)\", xlab = \"\") # Plot histogram of soil organic carbon values from representative observations hist(su.obs$su_repobs.sp$soc, 4, add = T, col = rgb(0,0,1,0.9)) # Add legend legend(\"topright\", legend = c(\"Sample\", \"Representative Observations\"),        col = c(rgb(0,1,0,0.8), rgb(0,0,1,0.9)), pch = 20, bty = \"n\", pt.cex = 2,        cex = 0.6, text.col = \"black\", horiz = F, inset = c(0, 0.05)       )"},{"path":"https://bafuentes.github.io/rassta/articles/sampling.html","id":"selection-of-representative-sampling-locations","dir":"Articles","previous_headings":"","what":"Selection of representative sampling locations","title":"Stratified Non-Probability Sampling","text":"cases sample observations response phenomenon available, rassta allows define XY locations can used establish field sampling campaigns. selection representative sampling locations performed stratification unit set, utilizes landscape similarity layers define XY locations. Currently, rassta allows select representative sampling locations based two approaches: buffer: selects XY location(s) within spatially contiguous areas landscape similarity values user-defined threshold. absolute: selects XY location(s) n highest landscape similarity values. code demonstrates selection representative sampling locations function locations(), based buffer method. spatial distribution representative sampling locations statistical distribution landscape similarity can plotted demonstrated code .  Clean files temporary directory","code":"# Representative sampling location and its buffer area for each stratification unit su.samp <- locations(ls.rast = su.ls$landsim, su.rast = su, method = \"buffer\") # Information about representative sampling locations and corresponding buffer areas su.samp$locations #>  class       : SpatVector  #>  geometry    : points  #>  dimensions  : 56, 2  (geometries, attributes) #>  extent      : 284072, 292532, 153351, 161841  (xmin, xmax, ymin, ymax) #>  coord. ref. : NAD83 / Washington South (EPSG:32149)  #>  names       :    SU land_sim #>  type        : <num>    <num> #>  values      :   111    92.67 #>                  112    89.33 #>                  113    90.67 su.samp$buffers #>  class       : SpatVector  #>  geometry    : polygons  #>  dimensions  : 56, 2  (geometries, attributes) #>  extent      : 284027, 292547, 153336, 161856  (xmin, xmax, ymin, ymax) #>  coord. ref. : NAD83 / Washington South (EPSG:32149)  #>  names       :    SU      area #>  type        : <num>     <num> #>  values      :   111  9.18e+04 #>                  112 1.026e+05 #>                  113 1.206e+05 # Set graphics arrangement par(mfrow = c(1,2)) # Plot stratification units, representative sampling locations and buffer areas plot(su, type = \"classes\", col = hcl.colors(56, \"spectral\"), legend = FALSE,      mar = c(3, 2, 3, 1.5), main = \"Representative Sampling Locations\",      fun = function() c(polys(su.samp$buffers, col = rgb(0,1,0,0.5)),                         points(su.samp$locations, pch = 21, col = \"black\",                                bg = rgb(0,1,0,1)                               )                       )     ) # Set new graphics arrangement par(mar = c(2, 1.5, 1.5, 1.5)) # Plot histogram of landscape similarity values at sampling locations hist(su.samp$locations$land_sim, 4, main = \"Landscape Similarity\") unlink(c(paste(o, \"/wasoil.zip\", sep = \"\"), d), recursive = TRUE)"},{"path":"https://bafuentes.github.io/rassta/articles/sampling.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Stratified Non-Probability Sampling","text":"B.. Fuentes, M.J. Dorantes, J.R. Tipton. rassta: Raster-based Spatial Stratification Algorithms. EarthArXiv, 2021. https://doi.org/10.31223/X50S57","code":""},{"path":"https://bafuentes.github.io/rassta/articles/signature.html","id":"selection-of-distribution-functions","dir":"Articles","previous_headings":"","what":"Selection of Distribution Functions","title":"Spatial Signature of Classification Units","text":"classification unit set, rassta allows select one distribution function following: probability density function (PDF) empirical cumulative distribution function (ECDF) inverted version empirical cumulative distribution function (iECDF)  rationale behind selection process given classification unit Z variable X, ‘optimal’ landscape configuration occurrence Z can associated typical values X within Z. Thus, position value within distribution function X indicator typical value within Z. rationale involves three important assumptions selecting distribution functions: PDF selected, classification unit mainly associated variable’s values approaching peak curve. ECDF selected, classification unit mainly associated variable’s values approaching +\\(\\infty\\). iECDF selected, classification unit mainly associated variable’s values approaching -\\(\\infty\\). Currently, rassta allows interactive automatic selection distribution functions classification unit set. interactive selection performed shiny app, automatic selection performed based following criteria: PDF = mean (median) variable’s values within classification unit neither maximum minimum mean (median) values across units. ECDF = mean (median) variable’s values within classification unit maximum mean (median) values across units. iECDF = mean (median) variable’s values within classification unit minimum mean (median) values across units. code demonstrates automatic selection distribution functions set 4 climatic classification units constructed using two variables (annual precipitation mean annual temperature). classification units, variables, selected distribution functions can visualized demonstrated code .","code":"# Load rassta and terra packages library(rassta) library(terra) # Multi-layer SpatRaster with 2 climatic variables var <- c(\"precipitation.tif\", \"temperature.tif\") vardir <- paste(d, var, sep = \"/\") clim.var <- rast(vardir) # Single-layer SpatRaster with 4 climatic classification units clim.cu <- rast(paste(d, \"/climate.tif\", sep = \"\")) # Automatic selection of statistical distribution functions clim.difun <- select_functions(cu.rast = clim.cu,                                var.rast = clim.var,                                 mode = \"auto\"                               ) # Plot climatic classification units and variables plot(c(clim.cu, clim.var), col = hcl.colors(100, \"Spectral\"), nc = 3,      mar = c(1.5, 1.5, 1.5, 5)     ) # Selected distribution functions knitr::kable(clim.difun$distfun, filter = \"none\", selection = \"none\")"},{"path":"https://bafuentes.github.io/rassta/articles/signature.html","id":"estimation-and-prediction-of-distribution-functions","dir":"Articles","previous_headings":"","what":"Estimation and prediction of distribution functions","title":"Spatial Signature of Classification Units","text":"set distribution functions selected classification unit, estimation prediction functions can performed predict_functions(). Given classification unit Z variable X, predict_functions() first estimates selected distribution function X, using observations selected within Z. Subsequently, predict_functions() fits locally-estimated scatterplot smoothing (LOESS). LOESS fitted using observations X explanatory values values corresponding distribution function response values. Finally, fitted LOESS predicted complete geographic space supported raster layer X. process repeated variable used construct Z. code demonstrates estimation prediction distribution functions predict_functions().","code":"# Multi-layer SpatRaster of climatic variables and classification units clim.all <- c(clim.var, clim.cu) # Ouput table from select_functions() df <- clim.difun$distfun # Predicted distribution functions for climatic variables clim.pdif <- predict_functions(cuvar.rast = clim.all, cu.ind = 3,                                 cu = df$Class.Unit,                                vars = df$Variable,                                dif = df$Dist.Func                               ) plot(clim.pdif, col = hcl.colors(100, \"Oslo\", rev = TRUE), nc = 4,      mar = c(1.5, 1.5, 1.5, 3.5)     )"},{"path":"https://bafuentes.github.io/rassta/articles/signature.html","id":"aggregation-of-predicted-distribution-functions","dir":"Articles","previous_headings":"","what":"Aggregation of predicted distribution functions","title":"Spatial Signature of Classification Units","text":"function signature() calculates spatial signature given classification unit aggregating predicted distribution functions associated unit.  argument inprex allows identification layers SpatRaster object represent predicted distribution functions classification unit set. Similarly, argument outname assigns unique name layer resulting SpatRaster spatial signatures. Clean files temporary directory","code":"# Spatial signatures from predicted distribution functions clim.sig <- signature(pdif.rast = clim.pdif,                       inprex = paste(seq(1, 4), \"_\", sep = \"\"),                       outname = paste(\"climate_\", seq(1, 4), sep = \"\")                     ) # Plot spatial signatures plot(clim.sig, col = hcl.colors(100, \"Oslo\", rev = TRUE), nc = 2,       mar = c(1.5, 1.5, 1.5, 3.5)) unlink(c(paste(o, \"/wasoil.zip\", sep = \"\"), d), recursive = TRUE)"},{"path":"https://bafuentes.github.io/rassta/articles/signature.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Spatial Signature of Classification Units","text":"B.. Fuentes, M.J. Dorantes, J.R. Tipton. rassta: Raster-based Spatial Stratification Algorithms. EarthArXiv, 2021. https://doi.org/10.31223/X50S57","code":""},{"path":"https://bafuentes.github.io/rassta/articles/similarity.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Landscape Similarity to Stratification Units","text":"B.. Fuentes, M.J. Dorantes, J.R. Tipton. rassta: Raster-based Spatial Stratification Algorithms. EarthArXiv, 2021. https://doi.org/10.31223/X50S57","code":""},{"path":"https://bafuentes.github.io/rassta/articles/stratunits.html","id":"spatial-intersection-of-classification-units","dir":"Articles","previous_headings":"","what":"Spatial intersection of classification units","title":"Stratification Units","text":"process create stratification units fairly simple. First, n sets classification units need loaded terra’s multi-layer SpatRaster object. Raster layers object must represent categorical data (.e., classification units). , function strata() used perform two processes: (1) spatial intersection raster layers, (2) assignment unique numeric code resulting unit. example, three sets classification units used create one set stratification units. sets classification units correspond () climatic, (ii) soil parent material, (iii) terrain classification units. maps show classification units interpretation set classification units.  following code demonstrates create stratification units three sets classification units function strata().","code":"# Load rassta and terra packages library(rassta) library(terra) # Multi-layer SpatRaster with 3 sets of classification units cu <- c(\"climate.tif\", \"material.tif\", \"terrain.tif\") cudir <- paste(d, cu, sep = \"/\") all.cu <- rast(cudir) # Plot the sets of classification units par(mfrow = c(3, 1)) plot(all.cu[[1]], type = \"classes\", main = \"Climatic Classification Units\",       col = hcl.colors(4, \"spectral\"), mar = c(1.5, 1.5, 1.5, 16),      levels = c(\"1. Highest Rainfall and Lowest Temperature\",                 \"2. High Rainfall and Low Temperature\",                 \"3. Low Rainfall and High Temperature\",                 \"4. Lowest Rainfall and Highest Temperature\"               )     ) plot(all.cu[[2]], type = \"classes\", main = \"Soil Parent Material Units\",       col = hcl.colors(6, \"spectral\"), mar = c(1.5, 1.5, 1.5, 16),      levels = c(\"1. Igneous\", \"2. Sedimentary\",                 \"3. Alluvium - Moderately weathered \",                 \"4. Alluvium - Somewhat weathered\",                 \"5. Alluvium - Rich in organic matter\",                 \"6. Alluvium - Rich in clay and organic matter\"                 )     ) plot(all.cu[[3]], type = \"classes\", main = \"Terrain Classification Units\",       col = hcl.colors(8, \"spectral\"), mar = c(1.5, 1.5, 1.5, 16),      levels = c(\"1. Summit\", \"2. Shoulder\", \"3. Backslope\",                 \"4. Backslope - Steep\", \"5. Footslope\",                 \"6. Footslope - Steep\", \"7. Toeslope\", \"8. Floodplain\"                 ) ) # Stratification units from the intersection of classification units su <- strata(cu.rast = all.cu) # Plot SpatRaster of stratification units plot(su$su.rast, type = \"classes\", main = \"Stratification Units\",      col = hcl.colors(length(unique(su$su.rast)[, 1]), \"spectral\"),      plg = list(ncol = 4), mar = c(1.5, 1.5, 1.5, 12)     )"},{"path":"https://bafuentes.github.io/rassta/articles/stratunits.html","id":"numeric-code-of-stratification-units","dir":"Articles","previous_headings":"","what":"Numeric code of stratification units","title":"Stratification Units","text":"numeric code makes possible trace back specific classification unit composes given stratification unit. code demonstrates retrieve multipliers used create numeric codes stratification units. multipliers indicate relative placement classification unit’s numeric ID landscape factor factor scale. example, classification unit climate denoted hundreds digit, soil parent material denoted tens digit, terrain denoted units digit. example, stratification unit 111 indicates spatial convergence climatic classification unit = 1 (highest rainfall lowest temperature), parent material classification unit = 1 (igneous), terrain classification unit = 1 (summit). Therefore, stratification unit 111 can interpreted summits located areas volcanic origin (igneous), exposed highest amount precipitation lowest temperature, compared rest landscape. Clean files temporary directory","code":"# Print multipliers used to code each stratification unit su$code.mult #>  climate material  terrain  #>      100       10        1 unlink(c(paste(o, \"/wasoil.zip\", sep = \"\"), d), recursive = TRUE)"},{"path":"https://bafuentes.github.io/rassta/articles/stratunits.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Stratification Units","text":"B.. Fuentes, M.J. Dorantes, J.R. Tipton. rassta: Raster-based Spatial Stratification Algorithms. EarthArXiv, 2021. https://doi.org/10.31223/X50S57","code":""},{"path":"https://bafuentes.github.io/rassta/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Bryan . Fuentes. Author, maintainer. Minerva J. Dorantes. Author. John R. Tipton. Author. Robert J. Hijmans. Contributor.","code":""},{"path":"https://bafuentes.github.io/rassta/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"B.. Fuentes, M.J. Dorantes, J.R. Tipton. rassta: Raster-based Spatial Stratification Algorithms. EarthArXiv, 2021. https://doi.org/10.31223/X50S57","code":"@Article{,   title = {rassta: {R}aster-based {S}patial {S}tratification {A}lgorithms},   author = {B. A. Fuentes and M. J. Dorantes and J. R. Tipton},   journal = {EarthArXiv},   year = {2021},   url = {https://doi.org/10.31223/X50S57}, }"},{"path":"https://bafuentes.github.io/rassta/index.html","id":"rassta","dir":"","previous_headings":"","what":"Raster-Based Spatial Stratification Algorithms","title":"Raster-Based Spatial Stratification Algorithms","text":"rassta (raster-based spatial stratification algorithms) collection algorithms spatial stratification landscapes, sampling, modeling spatially-varying phenomena R. rassta offers simple framework stratification geographic space based raster layers representing landscape factors /factor scales. stratification process follows hierarchical approach, based first level units (.e., classification units) second-level units (.e., stratification units). Nonparametric techniques allow measure correspondence geographic space landscape configuration represented units. correspondence metrics useful define sampling schemes model spatial variability environmental phenomena.","code":""},{"path":"https://bafuentes.github.io/rassta/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Raster-Based Spatial Stratification Algorithms","text":"rassta available CRAN, current released version can installed follows: install development version github, please use:","code":"install.packages(\"rassta\") remotes::install_github(\"bafuentes/rassta\")"},{"path":[]},{"path":"https://bafuentes.github.io/rassta/index.html","id":"acknowledgments","dir":"","previous_headings":"","what":"Acknowledgments","title":"Raster-Based Spatial Stratification Algorithms","text":"rassta greatly benefits past current efforts make spatial data analysis fully operational R, turn benefited titans like GDAL, PROJ, GEOS, etc. Special thanks minds behind terra, rgdal, rgeos, sf packages, behind packages rassta depends well.","code":""},{"path":"https://bafuentes.github.io/rassta/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Raster-Based Spatial Stratification Algorithms","text":"journal article describing analysis theoretical background rassta way. meantime, use rassta part research please cite EarthArXiv preprint work: B.. Fuentes, M.J. Dorantes, J.R. Tipton. rassta: Raster-based Spatial Stratification Algorithms. EarthArXiv, 2021. https://doi.org/10.31223/X50S57","code":""},{"path":"https://bafuentes.github.io/rassta/reference/dummies.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Dummy Layers from Categorical Raster Layers — dummies","title":"Create Dummy Layers from Categorical Raster Layers — dummies","text":"Given SpatRaster whose cell values represent categories (e.g., soil types, land use/cover classes), dummy layer indicating presence/absence category created, optionally written disk. category raster layer must represented unique integer cell value. Output values indicating presence absence categories dummy layers may set using preval absval arguments, respectively.","code":""},{"path":"https://bafuentes.github.io/rassta/reference/dummies.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Dummy Layers from Categorical Raster Layers — dummies","text":"","code":"dummies(   ca.rast,   vals = NULL,   preval = 100,   absval = 0,   to.disk = FALSE,   outdir = \".\",   extension = \".tif\",   ... )"},{"path":"https://bafuentes.github.io/rassta/reference/dummies.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Dummy Layers from Categorical Raster Layers — dummies","text":"ca.rast SpatRaster, rast. Single-layer SpatRaster whose (integer) cell values represent numeric IDs categories. vals Integer. Vector sequence values representing categories dummy layers created. NULL, categories processed. Default: NULL preval Integer. Value indicating presence category. Default: 100 absval Integer. Value indicating absence category. Default: 0 .disk Boolean. Write output dummy layers disk? Default: FALSE outdir Character. .disk = TRUE, string specifying path output dummy raster layers. Default: \".\" extension Character. .disk = TRUE, String specifying extension output raster layers (see Details). Default: \".tif\" ... .disk = TRUE, additional arguments writeRaster.","code":""},{"path":"https://bafuentes.github.io/rassta/reference/dummies.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Dummy Layers from Categorical Raster Layers — dummies","text":"Single-layer multi-layer SpatRaster dummy layer(s).","code":""},{"path":"https://bafuentes.github.io/rassta/reference/dummies.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create Dummy Layers from Categorical Raster Layers — dummies","text":"function mainly differs segregate presence absence values can set arbitrarily, thus allowing values traditionally used one-hot/dummy encoding (.e., 1 0). Please note argument extension correspond argument filetype writeRaster. However, writeRaster recognize appropriate extension output raster layers extension argument. instance, setting extension = \".tif\", writeRaster recognize extension GeoTiff, GDAL driver name.","code":""},{"path":[]},{"path":"https://bafuentes.github.io/rassta/reference/dummies.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create Dummy Layers from Categorical Raster Layers — dummies","text":"","code":"require(terra) #> Loading required package: terra #> terra 1.5.21 p <- system.file(\"exdat\", package = \"rassta\") # Single-layer SpatRaster of geologic units f <- list.files(path = p, pattern = \"geology2.tif\", full.names = TRUE) geol <- terra::rast(f) # Dummy layer from geologic unit 1 dummies <- dummies(ca.rast = geol, vals = 1, preval = 100, absval = 0)"},{"path":"https://bafuentes.github.io/rassta/reference/engine.html","id":null,"dir":"Reference","previous_headings":"","what":"Predictive Modeling Engine — engine","title":"Predictive Modeling Engine — engine","text":"Modeling spatially varying phenomena based landscape similarity stratification units. stratification unit across geographic space represents distinct landscape configuration (terms multiple landscape factors /factor scales), landscape configuration influences phenomenon distinct way, spatial variability phenomenon can assessed across landscape relating geographic location distinct landscape configuration. Therefore, similar geographic location landscape configuration represented given stratification unit, also similar response phenomenon location typical response conditions within given stratification unit. continuous categorical response variables supported. categorical responses, category must identified integer value.","code":""},{"path":"https://bafuentes.github.io/rassta/reference/engine.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predictive Modeling Engine — engine","text":"","code":"engine(   res.type = \"cont\",   ls.rast,   n.win = 3,   su.repobs,   tiles,   parallel = FALSE,   outdir = \".\",   tile.rm = TRUE,   extension = \".tif\",   verbose = FALSE,   ... )"},{"path":"https://bafuentes.github.io/rassta/reference/engine.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predictive Modeling Engine — engine","text":"res.type Character. Type response model. Options \"cont\" continuous, \"cat\" categorical response. Default: \"cont\" ls.rast SpatRaster, rast. Multi-layer SpatRaster representing landscape similarities stratification units. similarities units representative observation allowed. Character prefix file name similarities allowed. n.win Integer. Positive number indicating many winning stratification units considered. See Details. Default: 3 su.repobs Data frame. first column data frame must contain numeric code stratification units (without prefix). additional column must contain value representative response observation stratification unit. Multiple response variables allowed (one per column). Note response variables data frame must share type (res.type). See example issues related non-explicit column names. tiles SpatVector, vect. Spatial vector polygon geometry boundaries area interest. vector can subdivided regions (.e., tiles) balance memory allocation processing speed (see Details). vector tiled, attribute table must contain ID column unique identifier tile (1,2,...,n). Additionally, vector must coordinate reference system ls.rast. parallel Boolean. Perform parallel processing? parallel backend needs registered beforehand registerDoParallel. Moreover, tiled spatial vector supplied tiles. Default: FALSE outdir Character. String specifying path output raster tiles/layer(s) modeled response(s). Default: \".\" tile.rm Boolean. tiles modeled response(s) removed disk tile merging process? Default: TRUE extension Character. String specifying extension output raster layer(s) modeled response(s). Default: \".tif\" verbose Boolean. Show warning messages console? Default: FALSE ... Additional arguments writeRaster.","code":""},{"path":"https://bafuentes.github.io/rassta/reference/engine.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predictive Modeling Engine — engine","text":"Multi-layer single-layer SpatRaster modeled response(s).","code":""},{"path":"https://bafuentes.github.io/rassta/reference/engine.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Predictive Modeling Engine — engine","text":"predictive modeling process cell-wise, means operates cell--cell basis. given cell occurring geographic space supported raster layer, predictive modeling engine first identifies n stratification units given cell similar (.e., 'winning stratification units'). engine able identify winning stratification units thanks user-provided set landscape similarity layers ls.rast. Subsequently, response value representative observation winning stratification unit identified. case continuous response, weighted average representative response values performed. representative response value, weight proportional corresponding stratification unit's landscape similarity value given cell. result weighted average assigned response value given cell. case categorical response, modal value representative response values n winning stratification units assigned given cell. Note name raster layer ls.rast match numeric code corresponding stratification unit, obtained column numeric codes su.repobs. Nevertheless, raster layer names ls.rast character prefix numeric code /file extension work fine (e.g., \"su_1101.tif\" instead \"1101\"). landscape similarity layers ls.rast created similarity, raster layer names prefix extension part numeric code. dealing large geographic spaces, high raster resolutions (.e., small cell sizes), , considerable amount memory required perform modeling process. reduce memory usage, predictive modeling engine performs tile-based processing landscape similarity layers writes results directly disk. Tile-based processing increases computational time, thus parallelization allowed setting parallel backend. parallelization enabled, care must taken size tiles since larger sizes greater impact memory usage. Consequently, parallel, tile-based processing less useful.","code":""},{"path":[]},{"path":"https://bafuentes.github.io/rassta/reference/engine.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predictive Modeling Engine — engine","text":"","code":"require(terra) p <- system.file(\"exdat\", package = \"rassta\") # Multi-layer SpatRaster of landscape similarities fls <- list.files(path = p, pattern = \"su_\", full.names = TRUE) ls <- terra::rast(fls) # Numeric code and representative response value for stratification units fro <-list.files(path = p, pattern = \"repobs.csv\", full.names = TRUE) ro <- read.csv(fro) # Extract only those stratification units with representative value ls <- ls[[as.character(ro$SU)]] # SpatVector with processing tiles fti <- list.files(path = p, pattern = \"tiles.shp\", full.names = TRUE) ti <- terra::vect(fti) # Directory for temporary files o <- tempdir() # Perform predictive modeling of continuous response r <- engine(res.type = \"cont\", ls.rast = ls, n.win = 2, su.repobs = ro,             tiles = ti, outdir = o, overwrite = TRUE            ) #> Warning: [src] \"src\" will be removed. It has been renamed to \"sprc\" # Plot modeled response if(interactive()){plot(r)} # Clean temporary files file.remove(list.files(path = o, pattern = \"soc.tif\", full.names = TRUE)) #> [1] TRUE # #------- # A note on non-explicit response's names (obtained from su.repobs):  ## This will result in incorrectly modeled response values x <- c(\"SOM\", \"SOM_30cm\", \"SOM_45cm\")    # SOM = soil organic matter grep(x[1], x)                            # Non explicit #> [1] 1 2 3 grep(x[2], x)                            # Explicit #> [1] 2 grep(x[3], x)                            # Explicit #> [1] 3  ## This will result in correct values x <- c(\"SOM_15cm\", \"SOM_30cm\", \"SOM_45cm\") grep(x[1], x)                            # Explicit #> [1] 1 grep(x[2], x)                            # Explicit #> [1] 2 grep(x[3], x)                            # Explicit #> [1] 3"},{"path":"https://bafuentes.github.io/rassta/reference/figure.html","id":null,"dir":"Reference","previous_headings":"","what":"Reproduce Figures from Fuentes et al. (n.d.) — figure","title":"Reproduce Figures from Fuentes et al. (n.d.) — figure","text":"function intended reproduce figures presented rassta: Raster-based Spatial Stratification Algorithms (Fuentes et al., 2021). Note function assumes necessary inputs figure loaded working environment. creation input, please refer data examples presented aforementioned work. Also, please note use function intended RStudio.","code":""},{"path":"https://bafuentes.github.io/rassta/reference/figure.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reproduce Figures from Fuentes et al. (n.d.) — figure","text":"","code":"figure(x, d, scaling = 100, to.disk = FALSE, verbose = FALSE)"},{"path":"https://bafuentes.github.io/rassta/reference/figure.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reproduce Figures from Fuentes et al. (n.d.) — figure","text":"x Integer. Number identifying figure reproduce. d List. List data required figure reproduce. scaling Integer. number scales (.e., resizes) R's plotting device, width = x/scaling & height = x/scaling, x = pixels. default pixel size (adjustable) scaling value work fine. Default = 100 .disk Boolean. Save figure disk? Default = FALSE verbose Boolean. Show warning messages console? Default: FALSE","code":""},{"path":"https://bafuentes.github.io/rassta/reference/figure.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reproduce Figures from Fuentes et al. (n.d.) — figure","text":"None","code":""},{"path":"https://bafuentes.github.io/rassta/reference/figure.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Reproduce Figures from Fuentes et al. (n.d.) — figure","text":"B.. Fuentes, M.J. Dorantes, J.R. Tipton. rassta: Raster-based Spatial Stratification Algorithms. EarthArXiv, 2021. doi: 10.31223/X50S57","code":""},{"path":[]},{"path":"https://bafuentes.github.io/rassta/reference/figure.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reproduce Figures from Fuentes et al. (n.d.) — figure","text":"","code":"if(interactive()){ require(terra) p <- system.file(\"exdat\", package = \"rassta\") # Single-layer SpatRaster of geologic units f <- list.files(path = p, pattern = \"geology.tif\", full.names = TRUE) geol <- terra::rast(f) # Dummy layers from geologic units mat.sig <- dummies(ca.rast = geol, preval = 100, absval = 0) figure(17, d = mat.sig) }"},{"path":"https://bafuentes.github.io/rassta/reference/locations.html","id":null,"dir":"Reference","previous_headings":"","what":"Select Representative Sampling Locations for Stratification Units — locations","title":"Select Representative Sampling Locations for Stratification Units — locations","text":"Selection representative sampling locations based landscape similarity values. give stratification unit, representative sampling location XY position highest landscape similarity value occurs. location assumed best reflect influence landscape configuration given stratification unit exerts response phenomena. Currently, two selection methods supported: (1) maximum similarity within buffer zones (\"buffer\"), (2) absolute maximum similarity (\"absolute\"). buffer method, n largest zones enclosing landscape similarity values certain threshold first identified. , zone, one sample placed XY location landscape similarity value maximized. absolute method, sample placed XY locations n maximum landscape similarity values. methods, possible constrain sampling process boundaries stratification unit. Constraining process ensures sampling locations determined given unit placed within boundaries unit. See Details guidance use function classification units.","code":""},{"path":"https://bafuentes.github.io/rassta/reference/locations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Select Representative Sampling Locations for Stratification Units — locations","text":"","code":"locations(   ls.rast,   su.rast,   method = \"buffer\",   constrained = TRUE,   buf.quant = 0.9,   buf.n = 1,   abs.n = 1,   tol = 2,   parallel = FALSE,   to.disk = FALSE,   outdir = \".\",   verbose = FALSE,   ... )"},{"path":"https://bafuentes.github.io/rassta/reference/locations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Select Representative Sampling Locations for Stratification Units — locations","text":"ls.rast SpatRaster, rast. Multi-layer SpatRaster representing landscape similarities stratification units. su.rast SpatRaster. Single-layer SpatRaster representing stratification units occurring across geographic space. Integer values expected cell values (.e., numeric codes) stratification units. method Character. String denoting sampling method. Current options \"buffer\" maximum similarity within buffer zones method, \"absolute\" absolute maximum similarity method. Default: \"buffer\" constrained Boolean. sampling process constrained boundaries stratification unit? See Details. Default: TRUE buf.quant Numeric. Number expressed quantile notation (0-1) indicating similarity threshold creation buffer zones. zones enclosing raster cells landscape similarity >= buf.quant created thus, considered sampling. See Details. Default: 0.9 buf.n Integer. Positive integer indicating n largest buffer zones sampling locations selected (n buffer zones per stratification unit, one sampling location per buffer zone). Default: 1 abs.n Integer. method = \"absolute\", Positive integer indicating number sampling locations select stratification unit. See Details. Default: 1 tol Numeric. number subtracted sampled maximum value landscape similarity layer ensure two things: (1) 'true' maximum similarity value found regardless size layer, (2) requested number sampling locations found (see Details). default assumes landscape similarity values scale 1 100. values different scale (e.g., decimal), , tol needs adjusted accordingly. Default: 2 parallel Boolean. Perform parallel processing? parallel backend must registered beforehand registerDoParallel. Keep mind amount RAM allocate performing parallel processing can result prohibitive large data sets. Default: FALSE .disk Boolean. output SpatVector(s) (vect) written disk? Default: FALSE outdir Character. .disk = TRUE, string specifying path output SpatVector(s). Default: \".\" verbose Boolean. Show warning messages console? Default: FALSE ... Additional arguments, writeVector.","code":""},{"path":"https://bafuentes.github.io/rassta/reference/locations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Select Representative Sampling Locations for Stratification Units — locations","text":"method = \"buffer\" constrained = TRUE, list following components: locations: SpatVector point geometry. point vector represents sampling location placed maximum landscape similarity value within stratification unit's buffer zone. Tabular attributes SpatVector (1) SU = stratification unit's numeric code, (2) land_sim = landscape similarity value, (3) x = X coordinate, (4) y = Y coordinate. buffer: SpatVector polygon geometry. polygon vector represents buffer zone stratification unit. method = \"buffer\" constrained = FALSE: locations: locations method = \"buffer\"constrained = TRUE. method = \"absolute\": locations: SpatVector point geometry. point vector represents sampling location placed maximum landscape similarity value stratification unit. Tabular attributes SpatVector (1) SU = stratification unit's numeric code, (2) land_sim = landscape similarity value, (3) x = X coordinate, (4) y = Y coordinate.","code":""},{"path":"https://bafuentes.github.io/rassta/reference/locations.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Select Representative Sampling Locations for Stratification Units — locations","text":"Except buf.n = 1 abs.n = 1, number returned sampling locations per stratification unit may smaller requested, especially constrained = TRUE. constrained buffer method, reducing landscape similarity threshold value buf.quant always result buffer zones; .e., sampling locations. reason reducing threshold value creation buffer zones may actually promote spatial contiguity zones. instance, two buffer zones created buf.quant = 0.9, may merged single buffer zone buf.quant = 0.80. occur raster cells two buffer zones satisfy: landscape similarity >= quantile(landscape similarity, 0.8). absolute method, increasing value tol argument ensure safer search n sampling locations thus, greater chances getting total number requested sampling locations per stratification unit. Note sampling scheme can applied classification units. order , one replace multi-layer SpatRaster landscape similarities multi-layer SpatRaster spatial signatures. One also replace raster layer stratification units classification units.","code":""},{"path":[]},{"path":"https://bafuentes.github.io/rassta/reference/locations.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Select Representative Sampling Locations for Stratification Units — locations","text":"","code":"require(terra) p <- system.file(\"exdat\", package = \"rassta\") # Multi-layer SpatRaster of landscape similarities fls <- list.files(path = p, pattern = \"su_\", full.names = TRUE) ls <- terra::rast(fls) # Single-layer SpatRaster of stratification units fsu <- list.files(path = p, pattern = \"strata.tif\", full.names = TRUE) su <- terra::rast(fsu) # Get 1 representative sampling location per stratification unit rl <- locations(ls.rast = ls, su.rast = su) #> Warning: [expanse] unknown CRS. Results can be wrong #> Warning: [expanse] unknown CRS. Results can be wrong #> Warning: [expanse] unknown CRS. Results can be wrong #> Warning: [expanse] unknown CRS. Results can be wrong #> Warning: [expanse] unknown CRS. Results can be wrong #> Warning: [expanse] unknown CRS. Results can be wrong #> Warning: [expanse] unknown CRS. Results can be wrong #> Warning: [expanse] unknown CRS. Results can be wrong #> Warning: [expanse] unknown CRS. Results can be wrong #> Warning: [expanse] unknown CRS. Results can be wrong #> Warning: [expanse] unknown CRS. Results can be wrong #> Warning: [expanse] unknown CRS. Results can be wrong #> Warning: [expanse] unknown CRS. Results can be wrong #> Warning: [expanse] unknown CRS. Results can be wrong #> Warning: [expanse] unknown CRS. Results can be wrong #> Warning: [expanse] unknown CRS. Results can be wrong #> Warning: [expanse] unknown CRS. Results can be wrong #> Warning: [expanse] unknown CRS. Results can be wrong # Plot representative locations (including buffer areas) if(interactive()){   plot(su, type = \"classes\", fun = function() c(points(rl$locations),                                                 polys(rl$buffers))       )}"},{"path":"https://bafuentes.github.io/rassta/reference/observation.html","id":null,"dir":"Reference","previous_headings":"","what":"Select the Representative Response Observation for Stratification Units — observation","title":"Select the Representative Response Observation for Stratification Units — observation","text":"Selection representative response observation stratification unit occurring across geographic space. One observation set n observations response variable sampled/measured within spatial boundaries given stratification unit selected according following criteria: (1) maximum landscape similarity, (2) median response value, (3) random selection. maximum landscape similarity (mls) selects observation XY spatial location landscape similarity value maximized given stratification unit. median response value (mrv) selects observation whose response value (closest ) median response values, measured observations spatially enclosed given stratification unit. random selection, implied name, randomly selects one observation set observations spatially enclosed given stratification unit. See Details guidance use function classification units.","code":""},{"path":"https://bafuentes.github.io/rassta/reference/observation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Select the Representative Response Observation for Stratification Units — observation","text":"","code":"observation(   su.rast,   obs,   col.id,   col.resp,   method = \"mls\",   ls.rast,   verbose = FALSE )"},{"path":"https://bafuentes.github.io/rassta/reference/observation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Select the Representative Response Observation for Stratification Units — observation","text":"su.rast SpatRaster, rast. Single-layer SpatRaster representing stratification units occurring across geographic space. Integer values expected cell values (.e., numeric codes) stratification units. obs SpatVector, vect. Vector point geometry whose tabular attributes contain ID column (1,2,...,n) column response' values. col.id Integer. Index ID column tabular attributes obs. col.resp Integer. Index response' values column tabular attributes obs. method Character. String specifying selection method response representative observation. Options \"mls\" maximum landscape similarity value, \"mrv\" median response value, \"random\" random selection. Default: \"mls\" ls.rast SpatRaster, rast. Multi-layer SpatRaster representing landscape similarities stratification units. required method = \"mls\". verbose Boolean. Show warning messages console? Default: FALSE","code":""},{"path":"https://bafuentes.github.io/rassta/reference/observation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Select the Representative Response Observation for Stratification Units — observation","text":"list following components: su.repobs: Data table following attributes: (1) Original IDs selected observation, (2) representative response value, (3) stratification unit's numeric code, (4) landscape similarity value XY location selected observation (method = \"mls\"). su.norepobs: List numeric codes stratification units without observations. su.repobs.sp: SpatVector point geometry representative response observation stratification unit represented su.rast.","code":""},{"path":"https://bafuentes.github.io/rassta/reference/observation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Select the Representative Response Observation for Stratification Units — observation","text":"selection scheme can applied classification units. classification units, one replace multi-layer SpatRaster landscape similarities multi-layer SpatRaster spatial signatures. One also replace raster layer stratification units classification units.","code":""},{"path":[]},{"path":"https://bafuentes.github.io/rassta/reference/observation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Select the Representative Response Observation for Stratification Units — observation","text":"","code":"require(terra) p <- system.file(\"exdat\", package = \"rassta\") # Single-layer SpatRaster of stratification units fsu <- list.files(path = p, pattern = \"strata.tif\", full.names = TRUE) su <- terra::rast(fsu) # Observations with response values. ## For this example, soil organic carbon (SOC) collected at 15 cm soil depth fob <- list.files(path = p, pattern = \"soc.shp\", full.names = TRUE) ob <- terra::vect(fob) # Column indices for ID and measured response value id <- 1 re <- 2 # Multi-layer SpatRaster of landscape similarities fls <- list.files(path = p, pattern = \"su_\", full.names = TRUE) ls <- terra::rast(fls) # Selection of representative response observations for stratification units ro <- observation(su.rast = su, obs = ob, col.id = id, col.resp = re,                   ls.rast = ls                  ) # Plot representative observations if(interactive()){plot(su, type = \"classes\",                        fun = function() points(ro$su_repobs.sp)                       )}"},{"path":"https://bafuentes.github.io/rassta/reference/plot3D.html","id":null,"dir":"Reference","previous_headings":"","what":"Interactive Maps of 3D surfaces — plot3D","title":"Interactive Maps of 3D surfaces — plot3D","text":"Interactive maps showing 3-dimensional (XYZ) variability raster layers representing continuous variables. XYZ reference positions obtained elevation layer values continuous variables used surface color gradient. function work, must raster layer elevation (e.g., digital terrain model) least one continuous variable among raster layers map. maps produced interactive, meaning manual axis rotation zoom possible. Special consideration must taken large raster layers (large spatial coverage /high spatial resolution). function can aggregates spatial resolution (.e., cell size) order handle large raster layers. achieved internally calling aggregate. aggregation factor determine final cell size, final cell size = cell size*aggregation factor. addition, spatial extent can provided reduce total mapping area thus, reduce processing time. function uses plotly library. See Details current limitations.","code":""},{"path":"https://bafuentes.github.io/rassta/reference/plot3D.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Interactive Maps of 3D surfaces — plot3D","text":"","code":"plot3D(   var.rast,   z,   ex = 0.1,   agg = FALSE,   fact = NULL,   spext = NULL,   pals = NA,   rev = NA )"},{"path":"https://bafuentes.github.io/rassta/reference/plot3D.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Interactive Maps of 3D surfaces — plot3D","text":"var.rast SpatRaster, rast. Multi-layer SpatRaster n continuous variables one layer representing surface/terrain elevation. z Integer. Position (index) raster layer elevation var.rast. ex Numeric. Value indicating exaggeration factor Z axis. can useful enhance visualization subtle topographic variability. Default: 0.1 agg Boolean. spatial resolution aggregated reduce processing time? Default: FALSE fact Numeric. agg = TRUE, value indicating aggregation factor. Default: NULL spext Numeric. List coordinates bounding box spatial subset (xmin, xmax, ymin, ymax). SpatRaster SpatVector spatial extent can calculated also acceptable input. Default: NULL pals Character. List strings names n color ramps (one per continuous variable). See hcl.colors. Default: NA rev Character. List n Booleans indicating whether reverse color ramp continuous variable. Default: NA","code":""},{"path":"https://bafuentes.github.io/rassta/reference/plot3D.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Interactive Maps of 3D surfaces — plot3D","text":"List plotly-htmlwidget objects. object calls 3D map continuous variable var.rast.","code":""},{"path":"https://bafuentes.github.io/rassta/reference/plot3D.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Interactive Maps of 3D surfaces — plot3D","text":"Currently, function allow adjust labels XY axes actual coordinates shown. Instead, relative position values shown axes.","code":""},{"path":[]},{"path":"https://bafuentes.github.io/rassta/reference/plot3D.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Interactive Maps of 3D surfaces — plot3D","text":"","code":"require(terra) p <- system.file(\"exdat\", package = \"rassta\") # Multi-layer SpatRaster of topographic variables ft <- list.files(path = p, pattern = \"^height|^slope|^wetness\",                  full.names = TRUE                 ) tvars <- terra::rast(ft) # Single-layer SpatRaster of terrain elevation fe <- list.files(path = p, pattern = \"^elevation\", full.names = TRUE) e <- terra::rast(fe) # Add elevation to the SpatRaster of topographic variables etvars <- c(e, tvars) # Interactive 3D maps maps <- plot3D(var.rast = etvars, z = 1, ex = 0.2,                pals = c(\"Zissou\", \"Plasma\", \"Spectral\")               ) if(interactive()){maps}"},{"path":"https://bafuentes.github.io/rassta/reference/predict_functions.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict Distribution Functions Across Geographic Space — predict_functions","title":"Predict Distribution Functions Across Geographic Space — predict_functions","text":"Predicts constrained, univariate distribution functions across geographic space supported raster layers. given continuous variable used create classification unit, function first calculates user-defined distribution function variable using observations selected within classification unit. way, distribution function univariate constrained. Subsequently, locally-estimated scatterplot smoothing fitted (see loess). LOESS fitted using variable’s observations explanatory values values distribution function response values. Finally, fitted LOESS predicted complete geographic space supported raster layer given variable. process iterated continuous variables classification units. resulting layer can thought landscape correspondence measurement XY location geographic space landscape configuration represented given classification unit terms specific variable. following distribution functions currently supported: probability density function (PDF), empirical cumulative density function (ECDF), inverse empirical cumulative density function (iECDF). Please refer Details information distribution function calculated. Also, see details parallel processing.","code":""},{"path":"https://bafuentes.github.io/rassta/reference/predict_functions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict Distribution Functions Across Geographic Space — predict_functions","text":"","code":"predict_functions(   cuvar.rast,   cu.ind,   cu,   vars,   dif,   hist.type = \"regular\",   hist.pen = \"default\",   grid.mult = 1,   kern = \"normal\",   quant.sep = 0.01,   span = 0.6,   to.disk = FALSE,   outdir = \".\",   prefix = \"\",   extension = \".tif\",   verbose = FALSE,   ... )"},{"path":"https://bafuentes.github.io/rassta/reference/predict_functions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict Distribution Functions Across Geographic Space — predict_functions","text":"cuvar.rast SpatRaster, rast. Multi-layer SpatRaster containing n continuous raster layers (.e., variables) one raster layer classification units integer cell values (.e., Numeric identifiers). cu.ind Integer. Position (index) raster layer classification units cuvar.rast. cu Integer. Vector integer values correspond numeric identifiers units raster layer classification units. vars Character. Vector strings containing names n continuous variables cuvar.rast. names sequentially repeated according number classification units (See Examples). dif Character. Vector strings containing distribution function calculate continuous variable within classification unit. function match position name distribution function name continuous variable vars. hist.type Character. Type histogram calculate. Options \"regular\", \"irregular\" (unequally-sized bins, computationally demanding), \"combined\" (one greater penalized likelihood returned). See histogram. Default: \"regular\" hist.pen Character. Penalty apply calculating histogram (see histogram). Default: \"default\" grid.mult Numeric. Multiplying factor increase/decrease size \"optimal\" grid size Kernel Density Estimate (KDE). Default: 1 kern Character. Type kernel use KDE. Default: \"normal\" quant.sep Numeric. Spacing quantiles calculation ECDF iECDF. Quantiles range 0-1 thus spacing must decimal. Default: 0.01 span Numeric. Degree smoothing LOESS. Default: 0.6 .disk Boolean. Write output raster layers predicted distribution function disk? See details parallel processing. Default: FALSE outdir Character. .disk = TRUE, string specifying path output raster layers predicted distribution function. Default: \".\" prefix Character. .disk = TRUE, string specifying prefix file names output raster layers predicted distribution function. Default: \"\" extension Character. .disk = TRUE, string specifying extension output raster layers predicted distribution function. Default: \".tif\" verbose Boolean. Show warning messages console? Default: FALSE ... .disk = TRUE, additional arguments writeRaster.","code":""},{"path":"https://bafuentes.github.io/rassta/reference/predict_functions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict Distribution Functions Across Geographic Space — predict_functions","text":"Single-layer multi-layer SpatRaster predicted distribution function variable classification unit.","code":""},{"path":"https://bafuentes.github.io/rassta/reference/predict_functions.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Predict Distribution Functions Across Geographic Space — predict_functions","text":"calculate PDF, function uses binned KDE observations drawn breaks regular/irregular histogram. \"optimal\" number bins histogram defined calling function histogram (Mildenberger et al., 2019) user-defined penalty hist.pen. Subsequently, optimal number bins treated equivalent \"optimal\" grid size binned KDE. grid size can adjusted specifying multiplying factor grid.mult. Lastly, \"optimal\" bandwidth binned KDE calculated applying direct plugin method Sheather Jones (1991). calculation optimal bandwidth binned KDE, package KernSmooth called. calculate ECDF iECDF, function calls ecdf function equally-spaced quantiles. spacing quantiles can manually adjusted via quant.sep. case iECDF, ECDF inverted applying formula: iECDF = ((x - max(ECDF)) * -1) + min(ECDF); x corresponds value ECDF. \"cu\", \"vars\", \"dif\" parameters function configured output table select_functions can used directly input. (see Examples). writing output raster layer disk, multiple distribution functions can predicted parallel parallel backend registered beforehand registerDoParallel. Keep mind function may require large amount memory using parallel backend large raster layers (.e., high resolution /large spatial coverage).","code":""},{"path":"https://bafuentes.github.io/rassta/reference/predict_functions.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Predict Distribution Functions Across Geographic Space — predict_functions","text":"T. Mildenberger, Y. Rozenholc, D. Zasada. histogram: Construction Regular Irregular Histograms Different Options Automatic Choice Bins, 2019. https://CRAN.R-project.org/package=histogram S. Sheather M. Jones. reliable data-based bandwidth selection method kernel density estimation. Journal Royal Statistical Society. Series B. Methodological, 53:683–690, 1991.","code":""},{"path":[]},{"path":"https://bafuentes.github.io/rassta/reference/predict_functions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predict Distribution Functions Across Geographic Space — predict_functions","text":"","code":"require(terra) p <- system.file(\"exdat\", package = \"rassta\") # Multi-layer SpatRaster of topographic variables ## 3 continuous variables ftva <- list.files(path = p, pattern = \"^height|^slope|^wetness\",                    full.names = TRUE                   ) tva <- terra::rast(ftva) # Single-layer SpatRaster of topographic classification units ## Five classification units ftcu <- list.files(path = p, pattern = \"topography.tif\", full.names = TRUE) tcu <- terra::rast(ftcu) # Add the classification units to the SpatRaster of topographic variables tcuvars <- c(tcu, tva) # Data frame with source for \"cu\", \"vars\", and \"dif\" ftdif <- list.files(path = p, pattern = \"topodif.csv\", full.names = TRUE) tdif <- read.csv(ftdif) # Check structure of source data frame head(tdif) #>   Class.Unit Variable Dist.Func #> 1          1   height      ECDF #> 2          1    slope       PDF #> 3          1  wetness       PDF #> 4          2   height       PDF #> 5          2    slope      ECDF #> 6          2  wetness     iECDF # Predict distribution functions ## 1 distribution function per variable and classification unit = 1 tpdif <- predict_functions(cuvar.rast = tcuvars, cu.ind = 1,                            cu = tdif$Class.Unit[1:3],                            vars = tdif$Variable[1:3],                            dif = tdif$Dist.Func[1:3],                            grid.mult = 3, span = 0.9                          ) # Plot predicted distribution functions if(interactive()){plot(tpdif, col = hcl.colors(100, \"Oslo\", rev = TRUE))}"},{"path":"https://bafuentes.github.io/rassta/reference/select_functions.html","id":null,"dir":"Reference","previous_headings":"","what":"Select Constrained Univariate Distribution Functions — select_functions","title":"Select Constrained Univariate Distribution Functions — select_functions","text":"Selection distribution functions continuous raster layers used create raster layer classification units. distribution functions currently supported probability density function (PDF), empirical cumulative density function (ECDF), inverse empirical cumulative density function (iECDF). Please note select_functions calculate aforementioned distribution functions. sole purpose select_functions assist knowledge-driven selection appropriate distribution function continuous variable used create given classification unit (see Details).","code":""},{"path":"https://bafuentes.github.io/rassta/reference/select_functions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Select Constrained Univariate Distribution Functions — select_functions","text":"","code":"select_functions(   cu.rast,   var.rast,   fun = mean,   varscale = \"uniminmax\",   mode = \"auto\",   verbose = TRUE,   ... )"},{"path":"https://bafuentes.github.io/rassta/reference/select_functions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Select Constrained Univariate Distribution Functions — select_functions","text":"cu.rast SpatRaster, rast. Single-layer SpatRaster representing classification units occurring across geographic space. cell values (.e., numeric IDs) classification units must integer values. var.rast SpatRaster. Multi-layer SpatRaster containing n continuous raster layers variables used create classification units. fun Character. Descriptive statistical measurement (e.g., mean, max). See zonal. Default: mean varscale Character. Variable scaling method. See scale argument ggparcoord. Default: \"uniminmax\" mode Character. String specifying selection mode univariate distribution functions. Possible values \"inter\" interactive selection, \"auto\" automatic selection (see Details). Default: \"auto\" verbose Boolean. Show warning messages console? Default: FALSE ... Additional arguments ggparcoord.","code":""},{"path":"https://bafuentes.github.io/rassta/reference/select_functions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Select Constrained Univariate Distribution Functions — select_functions","text":"mode = \"inter\": distfun: DT table (DataTables library) following attributes: (1) Class.Unit = numeric ID classification units, (2) Variable = n continuous raster layers classification unit, (3) Dist.Func = Empty column whose cells can filled following strings: \"PDF, \"ECDF\", \"iECDF\" (unquoted). table can saved disk Shiny interface. parcoord: ploty-based parallel coordinate plot can saved disk using R package htmlwidgets. mode = \"auto\": distfun: distfun mode = \"inter\", except column \"Dist.Func\" whose cells automatically filled. parcoord: parcoord mode = \"inter\".","code":""},{"path":"https://bafuentes.github.io/rassta/reference/select_functions.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Select Constrained Univariate Distribution Functions — select_functions","text":"selection distribution functions univariate, , variable, constrained, meaning selection made classification unit. Overall, distribution functions used characterize typical values given continuous variable within given classification unit. PDF selected, values closer , peak PDF considered typical. Contrarily, values tails PDF considered less typical. ECDF iECDF selected, values toward (+)infinity (-)infinity considered typical values, respectively. order assist selection process, mode = \"inter\", function displays interactive parallel coordinates plot (see ggplotly) writable table (built Shiny). variable, parallel coordinates plot shows trend descriptive statistical measurement (argument fun) across classification units. Using trend, one can select appropriate distribution function variable based occurrence/absence \"peaks\" \"pits\" observed trend. instance, peak (highest point trend) indicate given classification unit contains average, highest values variable. Conversely, pit (lowest point trend) indicate given classification unit contains average, lowest values variable. Thus, ECDF iECDF can selected peak pit, respectively. PDF can selected classification units whose trend show either peak pit. Please consider peaks pits reference points thus, one validate selection distribution functions based domain knowledge. mode = \"auto\", criteria selection distribution functions based peaks pits parallel coordinates plot. output table (distfun) intended used input predict_functions function. selection distribution functions similar selection membership functions fuzzy logic. example, one wants describe phenomenon distribution functions continuous variables, functions can considered membership curves. Accordingly, PDF, ECDF, iECDF equivalent Gaussian, S, Z membership functions, respectively.","code":""},{"path":[]},{"path":"https://bafuentes.github.io/rassta/reference/select_functions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Select Constrained Univariate Distribution Functions — select_functions","text":"","code":"require(terra) p <- system.file(\"exdat\", package = \"rassta\") # Multi-layer SpatRaster of topographic variables ## 3 topographic variables tf <- list.files(path = p, pattern = \"^height|^slope|^wetness\",                  full.names = TRUE                 ) tvars <- terra::rast(tf) # Single-layer SpatRaster of topographic classification units ## 5 classification units tcf <- list.files(path = p, pattern = \"topography.tif\", full.names = TRUE) tcu <- terra::rast(tcf) # Automatic selection of distribution functions tdif <- select_functions(cu.rast = tcu, var.rast = tvars, fun = mean) #> Registered S3 method overwritten by 'GGally': #>   method from    #>   +.gg   ggplot2 # Parallel coordinates plot if(interactive()){tdif$parcoord}"},{"path":"https://bafuentes.github.io/rassta/reference/signature.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the Spatial Signature of Classification Units — signature","title":"Calculate the Spatial Signature of Classification Units — signature","text":"Using mathematical function, raster layer created cell-wise aggregation set predicted distribution functions classification unit (see predict_functions). element set can thought correspondence measurement XY location geographic space landscape configuration represented given classification unit terms specific variable. Therefore, aggregating set predicted distribution functions single layer produces overall (multivariate) measurement correspondence. multivariate landscape correspondence metric considered spatial signature classification unit.","code":""},{"path":"https://bafuentes.github.io/rassta/reference/signature.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the Spatial Signature of Classification Units — signature","text":"","code":"signature(   pdif.rast,   inprex,   outname,   fun = mean,   to.disk = FALSE,   outdir = \".\",   extension = \".tif\",   overwrite = FALSE,   ... )"},{"path":"https://bafuentes.github.io/rassta/reference/signature.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the Spatial Signature of Classification Units — signature","text":"pdif.rast SpatRaster, rast. Multi-layer SpatRaster whose raster layers represent predicted distribution functions continuous variables one classification units. predicted distribution functions particular classification unit considered part set. must matching pattern names predicted distribution functions set (see inprex). inprex Character. Prefix name raster layers representing predicted distribution functions belonging set (.e.,classification unit). spatial signatures multiple sets calculated, vector strings must provided. See Details Examples. outname Character. Output layer/file name raster layer(s) spatial signature. spatial signatures multiple classification units calculated, vector strings must provided. fun Function. mathematical function must take vector values return single value (e.g., mean, max, sum, etc.). See app. Default: mean .disk Boolean. Write output raster layer(s) spatial signature disk? See details parallel processing. Default: FALSE outdir Character. .disk = TRUE, string specifying path output  raster layer(s) spatial signature. Default: \".\" extension Character. .disk = TRUE, String specifying extension output raster layer(s) spatial signature. Default: \".tif\" overwrite Boolean. .disk = TRUE, raster layers disk name output raster layer(s) spatial signature overwritten? Default: FALSE ... .disk = TRUE, additional arguments writeRaster.","code":""},{"path":"https://bafuentes.github.io/rassta/reference/signature.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the Spatial Signature of Classification Units — signature","text":"Single-layer multi-layer SpatRaster spatial signature(s) calculated set(s) predicted distribution functions.","code":""},{"path":"https://bafuentes.github.io/rassta/reference/signature.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate the Spatial Signature of Classification Units — signature","text":"Raster layers predicted distribution functions belonging classification unit must identified unique prefix layer names (argument inprex). prefix used string pattern find predicted distribution functions belonging one classification unit. Consequently, unique prefix must defined additional classification unit distinguish predicted distribution functions different classification units. Similarly, additional string (vector strings) file/layer name(s) must provided distinguish resulting spatial signatures different classification units (argument outname). length outname must match inprex. writing output raster layers spatial signature disk, parallel backend can registered running function registerDoParallel speed-computation. Note helpful calculating spatial signatures many classification units. spatial analysis standpoint, aggregation predicted distribution functions spatial signature similar application fuzzy aggregation operators commonly used GIS-based multi-criteria decision analysis. Moreover, use descriptive statistics calculate signatures landscape-related classification units can traced back works Pike Rozema (1975), Pike (1988).","code":""},{"path":"https://bafuentes.github.io/rassta/reference/signature.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculate the Spatial Signature of Classification Units — signature","text":"R. Pike. geometric signature: quantifying landslide-terrain types digital elevation models. Mathematical geology, 20(5):491–511, 1988. doi: 10.1007/BF00890333 R. Pike W. Rozema. Spectral analysis landforms. Annals Association American Geographers,65(4):499–516, 1975. doi: 10.1111/j.1467-8306.1975.tb01058.x","code":""},{"path":[]},{"path":"https://bafuentes.github.io/rassta/reference/signature.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the Spatial Signature of Classification Units — signature","text":"","code":"require(terra) p <- system.file(\"exdat\", package = \"rassta\") # Multi-layer SpatRast with predicted distribution functions ## 3 continuous variables and 5 classification units, = 15 functions ft <- list.files(path = p, pattern = \"topo_\", full.names = TRUE) t <- terra::rast(ft) # Vector with the prefix for each set of predicted distribution functions ## 5 classification units = 5 sets it <- paste(\"topo_\", seq(1, 5), \"_\", sep = \"\") # Vector of names for output raster layers of spatial signature ## 5 spatial signatures, one per classification unit ot <- paste(\"topography_\", seq(1, 5), sep = \"\") # Calculate spatial signatures tsig <- signature(pdif.rast = t, inprex = it, outname = ot) # Plot spatial signatures if(interactive()){plot(tsig, col = hcl.colors(100, \"Oslo\", rev = TRUE))}"},{"path":"https://bafuentes.github.io/rassta/reference/similarity.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the Landscape Similarity to Stratification Units — similarity","title":"Calculate the Landscape Similarity to Stratification Units — similarity","text":"stratification unit present single-layer SpatRaster, raster layer landscape similarity created aggregating stratification unit's corresponding set spatial signatures (see signature). stratification unit x, corresponding set spatial signatures consists one spatial signature n classification units present numeric code x (one classification unit per landscape factor/factor scale). aggregation process performed cell-wise, using mathematical function takes multiple values return single value (e.g., mean, sum, min, max). resulting raster layer represents correspondence XY location geographic space landscape configuration represented given stratification unit.","code":""},{"path":"https://bafuentes.github.io/rassta/reference/similarity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the Landscape Similarity to Stratification Units — similarity","text":"","code":"similarity(   su.rast,   su.code,   sig.rast,   fun = mean,   to.disk = FALSE,   outdir = \".\",   prefix = \"su_\",   extension = \".tif\",   overwrite = FALSE,   ... )"},{"path":"https://bafuentes.github.io/rassta/reference/similarity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the Landscape Similarity to Stratification Units — similarity","text":"su.rast SpatRaster, rast. Single-layer SpatRaster representing stratification units occurring across geographic space. Integer values expected cell values (.e., numeric codes) stratification units. su.code List. structure stratification units' numeric code. (nested) list indicate names landscape factors/factor scales used create stratification units, position (start, end) corresponding classification units' ID numeric code. See Examples. sig.rast SpatRaster. Multi-layer SpatRaster spatial signatures classification units used create stratification units. spatial signatures follow name convention: x_n; x landscape factor/factor scale, n numeric ID classification unit spatial signature belongs. fun Function. mathematical function must accept vector values return single value (e.g., mean, max, sum, etc.). See app. Default: mean .disk Boolean. Write output raster layers landscape similarity disk? See note parallel processing. Default: FALSE outdir Character. .disk = TRUE, string specifying path output raster layers landscape similarity. Default: \".\" prefix Character. .disk = TRUE, prefix file name output raster layers landscape similarity. Default: \"su_\" extension Character. .disk = TRUE, string specifying extension output raster layers landscape signature. Default: \".tif\" overwrite Boolean. .disk = TRUE, raster layers disk name output landscape similarities overwritten? Default: FALSE ... Additional arguments writeRaster (.disk = TRUE).","code":""},{"path":"https://bafuentes.github.io/rassta/reference/similarity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the Landscape Similarity to Stratification Units — similarity","text":"list following components: landsim: Multi-layer SpatRaster landscape similarity stratification unit present su.rast. codes: data frame numeric code stratification unit corresponding classification units' numeric ID landscape factor/factor scale.","code":""},{"path":"https://bafuentes.github.io/rassta/reference/similarity.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate the Landscape Similarity to Stratification Units — similarity","text":"landscape similarity landscape correspondence metric. aggregation multiple spatial signatures single landscape similarity layer somewhat similar application fuzzy logic aggregation operators GIS-based multi-criteria decision analysis. Furthermore, aggregation raster layers indicating relative optimality spatially-varying phenomena, like spatial signatures, can guided physical/ecological principles like Sprengel-Liebig's law minimum. case, one select min function aggregating spatial signatures landscape similarities. writing output raster layers landscape similarity disk, parallel backend can registered running function registerDoParallel speed-computation.","code":""},{"path":[]},{"path":"https://bafuentes.github.io/rassta/reference/similarity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the Landscape Similarity to Stratification Units — similarity","text":"","code":"require(terra) p <- system.file(\"exdat\", package = \"rassta\") # Single-layer SpatRaster of stratification units fsu <- list.files(path = p, pattern = \"strata2.tif\", full.names = TRUE) su <- terra::rast(fsu) # Define the structure of the stratification units' numeric code code <- list(geology = c(1,1), climate = c(2,2), topography = c(3,3)) # Multi-layer SpatRaster of spatial signatures of classification units fsig <- list.files(path = p, pattern = \"geology_|climate_|topography_\",                    full.names = TRUE                   ) sig <- terra::rast(fsig) # Calculate landscape similarity to stratification units landsim <- similarity(su.rast = su, su.code = code, sig.rast = sig)  # Plot some landscape similarities # if(interactive()){plot(landsim$landsim[[c(1,10,12,14)]], #                        col = hcl.colors(100, \"Oslo\", rev = TRUE) #                       )}  #------- # A note on the numeric code of stratification units  # For a given stratification unit, the structure of its corresponding numeric # code indicates: (1) the landscape factors and/or factor scales that were # accounted for when creating the stratification unit, and (2) the numeric id # of the classification unit from each landscape factor/factor scale. # Consider the following numeric code structure:  su.code <- list(geology = c(1,1), climate = c(2,2), topography = c(3,4))  # The stratification units are composed of classification units from... # ...three landscape factors: geology, climate, and topography names(su.code) #> [1] \"geology\"    \"climate\"    \"topography\"  # For geology, the classification units are represented by the first... # ...digit in the numeric code su.code$geology #> [1] 1 1  # For climate, the classification units are represented by the second... # ...digit in the numeric code su.code$climate #> [1] 2 2 # For topography, the classification units are represented by the third... # ...and fourth digit in the numeric code su.code$topography #> [1] 3 4  # Thus, the numeric code of the stratification units 1101 and 2410 means: su <- c(1101, 2410) su[1]   # 'geology' = 1, 'climate' = 1, and 'topography' = 1 #> [1] 1101 su[2]   # 'geology' = 2, 'climate' = 4, and 'topography' = 10 #> [1] 2410"},{"path":"https://bafuentes.github.io/rassta/reference/som_gap.html","id":null,"dir":"Reference","previous_headings":"","what":"Self-Organizing Map and Selection of k — som_gap","title":"Self-Organizing Map and Selection of k — som_gap","text":"Produces low-dimensional representation input feature space subsequent estimation \"optimal\" number clusters (k) multivariate dataset. dimension reduction based self-organizing map technique (SOM) Kohonen (1982; 1990), implemented R function supersom Wehrens Kruisselbrink (2018). estimate optimal k, partitioning around medoids (PAM) Kaufman Rousseeuw (1990), coupled gap statistic Tibshirani et al. (2001), performed SOM's codebook vectors. achieved internally calling pam clusGap (Maechler et al., 2021). See Details brief theoretical background.","code":""},{"path":"https://bafuentes.github.io/rassta/reference/som_gap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Self-Organizing Map and Selection of k — som_gap","text":"","code":"som_gap(   var.rast,   xdim = 12,   ydim = 12,   topo = \"hexagonal\",   neighbourhood.fct = \"gaussian\",   rlen = 600,   dist.fcts = c(\"sumofsquares\", \"manhattan\"),   mode = \"pbatch\",   K.max,   stand = FALSE,   B = 500,   d.power = 2,   spaceH0 = \"original\",   method = \"globalSEmax\",   SE.factor = 1,   ... )"},{"path":"https://bafuentes.github.io/rassta/reference/som_gap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Self-Organizing Map and Selection of k — som_gap","text":"var.rast SpatRaster, rast. Multi-layer SpatRaster must contain n continuous variables SOM created. xdim Integer. Horizontal dimension SOM's grid. Default: 12 ydim Integer. Vertical dimension SOM's grid. Default: 12 topo Character. Topology SOM's grid. Options = \"rectangular\", \"hexagonal\". Default: \"hexagonal\" neighbourhood.fct Character. Neighborhood SOM's grid. Options = \"bubble\", \"gaussian\". Default: \"gaussian\" rlen Integer. Number times complete dataset presented SOM's network. Default: 600 dist.fcts Character. Vector length 2 containing distance functions use SOM (First element, options = \"sumofsquares\", \"euclidean\", \"manhattan\") PAM (second element, options = \"euclidean\", \"manhattan\"). Default: c(\"sumofsquares\", \"manhattan\") mode Character. Type learning algorithm. Options “online\", \"batch\", \"pbatch\". Default: \"pbatch\" K.max Integer. Maximum number clusters consider, must least two (2). stand Boolean. PAM function, SOM's codebook vectors need standardized? Default: FALSE B Integer. Number bootstrap samples gap statistic. Default: 500 d.power Integer. Positive Power applied euclidean distances gap statistic. Default: 2 spaceH0 Character. Space reference distribution gap statistic. Options = \"scaledPCA\", \"original\" (See Details). Default: \"original\" method Character. Optimal k selection criterion gap statistic. Options = \"globalmax\", \"firstmax\", \"Tibs2001SEmax\", \"firstSEmax\", \"globalSEmax\". See  clusGap details. Default: \"globalSEmax\" SE.factor Numeric. Factor feed standard error rule gap statistic. applicable methods based standard error (SE). See clusGap details. Default: 1 ... Additional arguments supersom.","code":""},{"path":"https://bafuentes.github.io/rassta/reference/som_gap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Self-Organizing Map and Selection of k — som_gap","text":"SOM: object class kohonen (see supersom). components class kohonen returned function : (1) data = original input matrix, (2) unit.classif = winning units observations, (3) distances = distance observation corresponding winning unit, (4) grid = object class somgrid (see somgrid), (5) codes = matrix codebook vectors, (6) changes = matrix mean average deviations codebook vectors, (7) dist.fcts = selected distance function, arguments passed supersom (e.g., radius, distance.weights, etc.). Note components 1, 2, 3 returned keep.data = TRUE, default. SOMdist: Object class dist. Matrix pairwise distances calculated SOM's codebook vectors. SOMgap: Object class clusGap. main component class clusGap returned function Tab, matrix gap statistic results (see clusGap). Additional components arguments passed function (.e., spaceH0, B), PAM function, n (number observations) call (clusGap call-type object). Kopt: Optimal k, selected arguments method (possibly) SE.factor.","code":""},{"path":"https://bafuentes.github.io/rassta/reference/som_gap.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Self-Organizing Map and Selection of k — som_gap","text":"clustering SOM's codebook vectors proposed several works, notably Vesanto Alhoniemi (2000). authors proposed two-stage clustering routine efficient method reduce computational load, obtaining satisfactory correspondence clustered codebook vectors clustered original feature space. main purpose function allow use clustering k-selection algorithms may result prohibitive large datasets, matrices derived raster layers commonly used geocomputational routines. Thus, SOM's codebook vectors can subsequently used calculation distance matrices, given large size input feature space, may otherwise impossible create due insufficient memory allocation capacity. Similarly, robust clustering algorithms require full pairwise distance matrices (e.g., hierarchical clustering, PAM) /eigenvalues (e.g., spectral clustering) may also performed SOM's codebook vectors. Note supersom internally equalize importance (.e., weights) variables differences scale affect distance calculations. behavior can prevented setting normalizeDataLayers = FALSE additional arguments passed supersom. Moreover, custom weights can also passed additional argument user.weights. case, user weights applied top internal weights. working large matrices, additional SOM argument keep.data may set FALSE. However, note , suggested follow-function raster products som_pam work since requires original data winning units. gap statistic, method = \"scaledPCA\" resulted errors R sessions BLAS/LAPACK supported Intel Math Kernel Library (MKL).","code":""},{"path":"https://bafuentes.github.io/rassta/reference/som_gap.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Self-Organizing Map and Selection of k — som_gap","text":"L. Kaufman P. Rousseeuw. Finding groups data: introduction cluster analysis. John Wiley & Sons, 1990. doi: 10.1002/9780470316801 T. Kohonen. Self-organized formation topologically correct feature maps. Biological cybernetics, 43 (1):59–69, 1982. doi: 10.1007/bf00337288 T. Kohonen. self-organizing map. Proceedings IEEE, 78(9):1464–1480, 1990. doi: 10.1016/s0925-2312(98)00030-7 M. Maechler, P. Rousseeuw, . Struyf, M. Hubert, K. Hornik. cluster: Cluster Analysis Basics Extensions, 2021. https://CRAN.R-project.org/package=cluster R. Tibshirani, G. Walther, T. Hastie. Estimating number clusters data set via gap statistic. Journal Royal Statistical Society: Series B (Statistical Methodology), 63(2):411–423, 2001. doi: 10.1111/1467-9868.00293 J. Vesanto E. Alhoniemi. Clustering self-organizing map. IEEE Transactions Neural Networks, 11(3):586–600, 2000. doi: 10.1109/72.846731 R. Wehrens J. Kruisselbrink. Flexible self-organizing maps kohonen 3.0. Journal Statistical Software, 87(1):1–18, 2018. doi: 10.18637/jss.v087.i07","code":""},{"path":[]},{"path":"https://bafuentes.github.io/rassta/reference/som_gap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Self-Organizing Map and Selection of k — som_gap","text":"","code":"require(terra) # Multi-layer SpatRaster with topographic variables p <- system.file(\"exdat\", package = \"rassta\") tf <- list.files(path = p, pattern = \"^height|^slope|^wetness\",                  full.names = TRUE                 ) t <- rast(tf) # Scale topographic variables (mean = 0, StDev = 1) ts <- scale(t) # Self-organizing map and gap statistic for optimum k set.seed(963) tsom <- som_gap(var.rast = ts, xdim = 8, ydim = 8, rlen = 150,                mode = \"online\", K.max = 6, B = 300, spaceH0 = \"original\",                method = \"globalSEmax\"               ) # Optimum k tsom$Kopt #> [1] 5"},{"path":"https://bafuentes.github.io/rassta/reference/som_pam.html","id":null,"dir":"Reference","previous_headings":"","what":"Rasterization of Self-Organizing Map and Partitioning Around Medoids — som_pam","title":"Rasterization of Self-Organizing Map and Partitioning Around Medoids — som_pam","text":"Creation rasterized representation outputs self-organizing map (SOM) partitioning around medoids (PAM). Given reference raster layer, SOM's winning unit PAM's clustering value mapped corresponding cell reference layer across geographic space supported layer. function follow-som_gap function. important note order som_pam work properly, reference layer ref.rast must cell size, number rows, number columns, index valid cells multi-layer SpatRaster object used som_gap.","code":""},{"path":"https://bafuentes.github.io/rassta/reference/som_pam.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rasterization of Self-Organizing Map and Partitioning Around Medoids — som_pam","text":"","code":"som_pam(ref.rast, kohsom, k, metric = \"manhattan\", stand = FALSE, ...)"},{"path":"https://bafuentes.github.io/rassta/reference/som_pam.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rasterization of Self-Organizing Map and Partitioning Around Medoids — som_pam","text":"ref.rast SpatRaster, rast. raster layer serve reference cell position geographic support rasterized representation SOM's winning units PAM's clustering. kohsom SOM Object class kohonen, see supersom. following components must present SOM object (1) unit.classif = winning units observations, (2) codes = matrix codebook vectors. k Integer (positive value). Number clusters form SOM's codebook vectors, k < SOM's codebook vectors. metric Character. Distance function PAM. Options \"euclidean\", \"manhattan\". Default: \"manhattan\" stand Boolean. PAM function, SOM's codebook vectors need standardized? Default: FALSE ... Additional arguments pam. See Details.","code":""},{"path":"https://bafuentes.github.io/rassta/reference/som_pam.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rasterization of Self-Organizing Map and Partitioning Around Medoids — som_pam","text":"sompam: Object class pam. See ?pam.object details. sompam.rast: Multi-layer SpatRaster, rast. first raster layer corresponds SOM's winning units. second raster layer corresponds clustered SOM's codebook vectors PAM.","code":""},{"path":"https://bafuentes.github.io/rassta/reference/som_pam.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Rasterization of Self-Organizing Map and Partitioning Around Medoids — som_pam","text":"som_gap, function calls pam perform clustering SOM's codebook vectors. SOM object must belong class kohonen, supersom. function work intended, additional argument cluster.pam must remain FALSE, default.","code":""},{"path":[]},{"path":"https://bafuentes.github.io/rassta/reference/som_pam.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rasterization of Self-Organizing Map and Partitioning Around Medoids — som_pam","text":"","code":"require(terra) # Multi-layer SpatRaster with topographic variables p <- system.file(\"exdat\", package = \"rassta\") ft <- list.files(path = p, pattern = \"^height|^slope|^wetness\",                  full.names = TRUE                 ) t <- rast(ft) # Scale topographic variables (mean = 0, StDev = 1) ts <- scale(t) # Self-organizing map and gap statistic for optimum k set.seed(963) tsom <- som_gap(var.rast = ts, xdim = 8, ydim = 8, rlen = 150,                mode = \"online\", K.max = 6, B = 300, spaceH0 = \"original\",                method = \"globalSEmax\"               ) # Optimum k tsom$Kopt #> [1] 5 # PAM clustering of topographic SOM's codebook vectors tpam <- som_pam(ref.rast = t[[1]], kohsom = tsom$SOM, k = tsom$Kopt) # Plot topographic variables, SOM grid and PAM clustering if(interactive()){plot(c(t, tpam$sompam.rast))}"},{"path":"https://bafuentes.github.io/rassta/reference/strata.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Stratification Units — strata","title":"Create Stratification Units — strata","text":"Stratification units created spatial intersection raster layers representing different sets classification units. set classification units related particular landscape factor (e.g., topography, climate) particular spatial scale single landscape factor (e.g., micro-climate, macro-topography). resulting stratification unit considered represent distinct landscape configuration terms multiple landscape factors/factor scales (represented classification units). function automatically assigns unique numeric code stratification unit. x stratification unit, numeric code represents unique combination classification units whose spatial intersection resulted x. See Examples get better idea logic behind code assignment process.","code":""},{"path":"https://bafuentes.github.io/rassta/reference/strata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Stratification Units — strata","text":"","code":"strata(cu.rast, to.disk = FALSE, outdir = \".\", su.name, ...)"},{"path":"https://bafuentes.github.io/rassta/reference/strata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Stratification Units — strata","text":"cu.rast SpatRaster, rast. Multi-layer SpatRaster layer represents set classification units particular landscape factor factor scale. Integer cell values (.e., numeric identifiers) expected. .disk Boolean. Write resulting raster layer stratification units disk? Default: FALSE outdir Character. .disk = TRUE, string specifying path output raster layer stratification units. Default: \".\" su.name Character. .disk = TRUE, file name (including extension) output raster layer stratification units. ... Additional arguments writeRaster.","code":""},{"path":"https://bafuentes.github.io/rassta/reference/strata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Stratification Units — strata","text":"su.rast: Single-layer SpatRaster representing stratification units occurring across geographic space. cell values raster layer represents numeric codes stratification units. code.mult: Multipliers used creation numeric codes. See Details.","code":""},{"path":"https://bafuentes.github.io/rassta/reference/strata.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create Stratification Units — strata","text":"printing su.rast$code.mult, output shows multiplier used landscape factor/factor scale. output, one can manually replicate creation stratification units simple raster algebra. , weighted sum SpatRasters containing classification units landscape factor/factor scale performed using multipliers weights. Note weights imply relative importance. weights required preserve logical structure landscape factors/factor scales resulting numeric code.","code":""},{"path":[]},{"path":"https://bafuentes.github.io/rassta/reference/strata.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create Stratification Units — strata","text":"","code":"require(terra) p <- system.file(\"exdat\", package = \"rassta\") # Multi-layer SpatRast with classification units (Cus) ## Three sets (i.e., landscape factors): geology, climate and topography fcu <- list.files(path = p,                   pattern = \"geology.tif|climate.tif|topography.tif\",                   full.names = TRUE                  ) cu <- terra::rast(fcu) # Stratification units (SUs) su <- strata(cu.rast = cu) # Plot the stratification units if(interactive()){plot(su$su.rast, type = \"classes\")} # # Note code structure from SUs and corresponding values from CUs z <- c(su$su.rast, cu)[46,61]   # Example of one cell (row = 45, column = 45) su$code.mult                    # Multipliers #>    geology    climate topography  #>        100         10          1  z[c(\"SU\", names(su$code.mult))] # Code structure #>    SU geology climate topography #> 1 245       2       4          5  # Note what happens when some landscape factors have cell values greater... #... than 1 digit (i.e., more than 9 distinct classification units) cu <- c(cu[[1]], cu[[2]]^4, cu[[3]]^2) su <- strata(cu.rast = cu) su$code.mult #>    climate    geology topography  #>      10000        100          1  c(su$su.rast, cu[[names(su$code.mult)]])[46,61] #>      SU climate geology topography #> 1 41625       4      16         25"},{"path":"https://bafuentes.github.io/rassta/news/index.html","id":"rassta-103","dir":"Changelog","previous_headings":"","what":"rassta 1.0.3","title":"rassta 1.0.3","text":"functions return SpatRaster objects now assign proper variable names instead getting names reference SpatRaster. Fixed bug prevented ‘select_functions()’ running properly argument ‘var.rast’ represents single-layer SpatRaster object. ‘select_functions()’ now allows work SpatRaster objects representing classification units whose numeric IDs sequentially defined (e.g., unordered classification units). Fixed bug prevented ‘strata()’ retrieving correct minimum maximum values SpatRaster objects NA values present, thus, assigning correct numeric codes stratification units.","code":""},{"path":"https://bafuentes.github.io/rassta/news/index.html","id":"rassta-102","dir":"Changelog","previous_headings":"","what":"rassta 1.0.2","title":"rassta 1.0.2","text":"CRAN release: 2021-12-09 functions renamed vignettes functions created.","code":""},{"path":"https://bafuentes.github.io/rassta/news/index.html","id":"rassta-101","dir":"Changelog","previous_headings":"","what":"rassta 1.0.1","title":"rassta 1.0.1","text":"CRAN release: 2021-10-14 Fixed violation CRAN’s policy regarding package code attempts write user library. Check logs can accessed : https://cran-archive.r-project.org/web/checks/2021/2021-10-08_check_results_rassta.html","code":""},{"path":"https://bafuentes.github.io/rassta/news/index.html","id":"rassta-100","dir":"Changelog","previous_headings":"","what":"rassta 1.0.0","title":"rassta 1.0.0","text":"CRAN release: 2021-09-22 Added NEWS.md file track changes package.","code":""}]
